{
  "master": {
    "tasks": [
      {
        "id": "1",
        "title": "Add Priority 1 Symbol Mappings to MTMathAtomFactory",
        "description": "Extend supportedLatexSymbols dictionary with high-impact missing symbols: blackboard bold letters (N,Z,Q,R,C), slanted inequalities (leqslant, geqslant), set relations (sqsubseteq, sqsupseteq, preceq, succeq), arrows (longmapsto), operators (wr, diamond, bowtie, vdash, dashv), Greek variants (varkappa, varpi, varrho, varsigma, digamma), and misc symbols (varnothing, square, Box, measuredangle, beth, gimel)",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Research Unicode code points for all Priority 1 symbols",
            "description": "Document the correct Unicode code points and atom types for all Priority 1 symbols: blackboard bold letters (N,Z,Q,R,C), slanted inequalities, set relations, arrows, operators, Greek variants, and misc symbols.",
            "dependencies": [],
            "details": "Create a reference document mapping each LaTeX command to its Unicode code point and MTMathAtomType. Verify code points against LaTeX standards and math font support. Symbols include: \\mathbb{N,Z,Q,R,C} (U+2115, U+2124, U+211A, U+211D, U+2102), \\leqslant (U+2A7D), \\geqslant (U+2A7E), \\sqsubseteq (already exists), \\sqsupseteq (already exists), \\preceq (U+227C), \\succeq (U+227D), \\longmapsto (U+27FC), \\wr (already exists), \\diamond (U+22C4), \\bowtie (U+22C8), \\vdash (U+22A2), \\dashv (U+22A3), \\varkappa (U+03F0), \\varpi (already exists), \\varrho (already exists), \\varsigma (needs fix), \\digamma (U+03DD), \\varnothing (U+2205 variant or U+2300), \\square (currently placeholder), \\Box (U+25A1), \\measuredangle (U+2221), \\beth (U+2136), \\gimel (U+2137).\n<info added on 2026-01-10T10:32:59.999Z>\nResearch completed with verified codebase analysis. Findings documented in tmp/20260110-1131_priority1_unicode_research.md.\n\nEXISTING SYMBOLS (8 confirmed, no action needed): sqsubseteq (U+2291), sqsupseteq (U+2292), wr (U+2240), uplus (U+228E), varrho (U+1D71A), varpi (U+1D71B), aleph (U+2135), emptyset (U+2205).\n\nBUG FIX REQUIRED: varsigma at line 164 has incorrect unicode U+03C1 (rho ρ) instead of U+03C2 (final sigma ς).\n\nNEW SYMBOLS TO ADD (20 total with copy-ready Swift code):\n- Slanted inequalities: leqslant (U+2A7D), geqslant (U+2A7E) - type: relation\n- Precedence: preceq (U+2AAF), succeq (U+2AB0) - type: relation\n- Arrows: longmapsto (U+27FC), hookrightarrow (U+21AA), hookleftarrow (U+21A9) - type: relation\n- Operators: diamond (U+22C4) - type: binaryOperator; bowtie (U+22C8), vdash (U+22A2), dashv (U+22A3) - type: relation\n- Greek: varkappa (U+03F0) - type: ordinary; digamma (U+03DD), Digamma (U+03DC) - type: variable\n- Miscellaneous: varnothing (U+2205), Box (U+25A1), measuredangle (U+2221), beth (U+2136), gimel (U+2137), daleth (U+2138) - type: ordinary\n\nNOTE: square command intentionally maps to placeholder() for editor cursor functionality; Box provides the standalone white square symbol.\n</info added on 2026-01-10T10:32:59.999Z>",
            "status": "done",
            "testStrategy": "Cross-reference each code point with Unicode charts and existing LaTeX documentation to ensure accuracy.",
            "updatedAt": "2026-01-10T10:33:19.332Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add blackboard bold letter N to supportedLatexSymbols",
            "description": "Add the \\N symbol mapping for blackboard bold capital N (natural numbers) to the supportedLatexSymbols dictionary in MTMathAtomFactory.swift.",
            "dependencies": [
              1
            ],
            "details": "Add entry \"N\" : MTMathAtom(type: .ordinary, value: \"\\u{2115}\") to the supportedLatexSymbols dictionary. This represents the set of natural numbers ℕ. The atom type should be .ordinary as it represents a mathematical set symbol, not an operator or relation.",
            "status": "done",
            "testStrategy": "Write unit test in MTMathListBuilderTests.swift that builds \\N and verifies the atom type is .ordinary and nucleus is ℕ (U+2115).",
            "parentId": "undefined",
            "updatedAt": "2026-01-10T13:02:29.146Z"
          },
          {
            "id": 3,
            "title": "Add blackboard bold letter Z to supportedLatexSymbols",
            "description": "Add the \\Z symbol mapping for blackboard bold capital Z (integers) to the supportedLatexSymbols dictionary in MTMathAtomFactory.swift.",
            "dependencies": [
              1
            ],
            "details": "Add entry \"Z\" : MTMathAtom(type: .ordinary, value: \"\\u{2124}\") to the supportedLatexSymbols dictionary. This represents the set of integers ℤ. The atom type should be .ordinary as it represents a mathematical set symbol.",
            "status": "done",
            "testStrategy": "Write unit test in MTMathListBuilderTests.swift that builds \\Z and verifies the atom type is .ordinary and nucleus is ℤ (U+2124).",
            "parentId": "undefined",
            "updatedAt": "2026-01-10T13:02:35.758Z"
          },
          {
            "id": 4,
            "title": "Add blackboard bold letter Q to supportedLatexSymbols",
            "description": "Add the \\Q symbol mapping for blackboard bold capital Q (rationals) to the supportedLatexSymbols dictionary in MTMathAtomFactory.swift.",
            "dependencies": [
              1
            ],
            "details": "Add entry \"Q\" : MTMathAtom(type: .ordinary, value: \"\\u{211A}\") to the supportedLatexSymbols dictionary. This represents the set of rational numbers ℚ. The atom type should be .ordinary as it represents a mathematical set symbol.",
            "status": "done",
            "testStrategy": "Write unit test in MTMathListBuilderTests.swift that builds \\Q and verifies the atom type is .ordinary and nucleus is ℚ (U+211A).",
            "parentId": "undefined",
            "updatedAt": "2026-01-10T13:02:42.381Z"
          },
          {
            "id": 5,
            "title": "Add blackboard bold letters R and C to supportedLatexSymbols",
            "description": "Add the \\R and \\C symbol mappings for blackboard bold capital R (reals) and C (complex) to the supportedLatexSymbols dictionary in MTMathAtomFactory.swift.",
            "dependencies": [
              1
            ],
            "details": "Add entries \"R\" : MTMathAtom(type: .ordinary, value: \"\\u{211D}\") and \"C\" : MTMathAtom(type: .ordinary, value: \"\\u{2102}\") to the supportedLatexSymbols dictionary. These represent the sets of real numbers ℝ and complex numbers ℂ respectively. Both should use atom type .ordinary.",
            "status": "done",
            "testStrategy": "Write unit tests in MTMathListBuilderTests.swift that build \\R and \\C and verify atom types are .ordinary and nuclei are ℝ (U+211D) and ℂ (U+2102).",
            "parentId": "undefined",
            "updatedAt": "2026-01-10T13:02:49.162Z"
          },
          {
            "id": 6,
            "title": "Add slanted inequality leqslant to supportedLatexSymbols",
            "description": "Add the \\leqslant symbol mapping for the slanted less-than-or-equal relation to the supportedLatexSymbols dictionary in MTMathAtomFactory.swift.",
            "dependencies": [
              1
            ],
            "details": "Add entry \"leqslant\" : MTMathAtom(type: .relation, value: \"\\u{2A7D}\") to the supportedLatexSymbols dictionary. This is the slanted variant of ≤ (leq). The atom type must be .relation for proper inter-atom spacing.",
            "status": "done",
            "testStrategy": "Write unit test that builds \\leqslant and verifies atom type is .relation and nucleus is ⩽ (U+2A7D). Also test spacing with adjacent atoms.",
            "parentId": "undefined",
            "updatedAt": "2026-01-10T13:03:01.375Z"
          },
          {
            "id": 7,
            "title": "Add slanted inequality geqslant to supportedLatexSymbols",
            "description": "Add the \\geqslant symbol mapping for the slanted greater-than-or-equal relation to the supportedLatexSymbols dictionary in MTMathAtomFactory.swift.",
            "dependencies": [
              1
            ],
            "details": "Add entry \"geqslant\" : MTMathAtom(type: .relation, value: \"\\u{2A7E}\") to the supportedLatexSymbols dictionary. This is the slanted variant of ≥ (geq). The atom type must be .relation for proper inter-atom spacing.",
            "status": "done",
            "testStrategy": "Write unit test that builds \\geqslant and verifies atom type is .relation and nucleus is ⩾ (U+2A7E). Also test spacing with adjacent atoms.",
            "parentId": "undefined",
            "updatedAt": "2026-01-10T13:03:07.207Z"
          },
          {
            "id": 8,
            "title": "Add preceq and succeq set relations to supportedLatexSymbols",
            "description": "Add the \\preceq and \\succeq symbol mappings for precedes-or-equals and succeeds-or-equals relations to the supportedLatexSymbols dictionary.",
            "dependencies": [
              1
            ],
            "details": "Add entries \"preceq\" : MTMathAtom(type: .relation, value: \"\\u{227C}\") and \"succeq\" : MTMathAtom(type: .relation, value: \"\\u{227D}\") to the supportedLatexSymbols dictionary. These represent the ordering relations ≼ and ≽. Both should use atom type .relation.",
            "status": "done",
            "testStrategy": "Write unit tests that build \\preceq and \\succeq and verify atom types are .relation with correct Unicode nuclei.",
            "parentId": "undefined",
            "updatedAt": "2026-01-10T13:17:37.046Z"
          },
          {
            "id": 9,
            "title": "Add longmapsto arrow to supportedLatexSymbols",
            "description": "Add the \\longmapsto symbol mapping for the long maps-to arrow to the supportedLatexSymbols dictionary in MTMathAtomFactory.swift.",
            "dependencies": [
              1
            ],
            "details": "Add entry \"longmapsto\" : MTMathAtom(type: .relation, value: \"\\u{27FC}\") to the supportedLatexSymbols dictionary. This is the long variant of \\mapsto (↦). The atom type should be .relation like other arrows in the existing codebase.",
            "status": "done",
            "testStrategy": "Write unit test that builds \\longmapsto and verifies atom type is .relation and nucleus is ⟼ (U+27FC). Compare with existing mapsto test.",
            "parentId": "undefined",
            "updatedAt": "2026-01-10T13:17:44.542Z"
          },
          {
            "id": 10,
            "title": "Add diamond operator to supportedLatexSymbols",
            "description": "Add the \\diamond symbol mapping for the diamond binary operator to the supportedLatexSymbols dictionary in MTMathAtomFactory.swift.",
            "dependencies": [
              1
            ],
            "details": "Add entry \"diamond\" : MTMathAtom(type: .binaryOperator, value: \"\\u{22C4}\") to the supportedLatexSymbols dictionary. This represents the diamond operator ⋄ used in binary operations. The atom type must be .binaryOperator for correct spacing.",
            "status": "done",
            "testStrategy": "Write unit test that builds \\diamond and verifies atom type is .binaryOperator and nucleus is ⋄ (U+22C4).",
            "parentId": "undefined",
            "updatedAt": "2026-01-10T13:17:51.317Z"
          },
          {
            "id": 11,
            "title": "Add bowtie relation to supportedLatexSymbols",
            "description": "Add the \\bowtie symbol mapping for the bowtie/join relation to the supportedLatexSymbols dictionary in MTMathAtomFactory.swift.",
            "dependencies": [
              1
            ],
            "details": "Add entry \"bowtie\" : MTMathAtom(type: .relation, value: \"\\u{22C8}\") to the supportedLatexSymbols dictionary. This represents the natural join/bowtie symbol ⋈ commonly used in relational algebra and logic. The atom type should be .relation.",
            "status": "done",
            "testStrategy": "Write unit test that builds \\bowtie and verifies atom type is .relation and nucleus is ⋈ (U+22C8).",
            "parentId": "undefined",
            "updatedAt": "2026-01-10T13:17:57.584Z"
          },
          {
            "id": 12,
            "title": "Add vdash and dashv turnstile relations to supportedLatexSymbols",
            "description": "Add the \\vdash and \\dashv symbol mappings for the turnstile relations to the supportedLatexSymbols dictionary in MTMathAtomFactory.swift.",
            "dependencies": [
              1
            ],
            "details": "Add entries \"vdash\" : MTMathAtom(type: .relation, value: \"\\u{22A2}\") and \"dashv\" : MTMathAtom(type: .relation, value: \"\\u{22A3}\") to the supportedLatexSymbols dictionary. These represent the turnstile ⊢ (proves/entails) and reverse turnstile ⊣ (true under). Both should use atom type .relation.",
            "status": "done",
            "testStrategy": "Write unit tests that build \\vdash and \\dashv and verify atom types are .relation with correct Unicode nuclei (U+22A2 and U+22A3).",
            "parentId": "undefined",
            "updatedAt": "2026-01-10T13:18:03.396Z"
          },
          {
            "id": 13,
            "title": "Add varkappa Greek variant to supportedLatexSymbols",
            "description": "Add the \\varkappa symbol mapping for the Greek letter kappa variant to the supportedLatexSymbols dictionary in MTMathAtomFactory.swift.",
            "dependencies": [
              1
            ],
            "details": "Add entry \"varkappa\" : MTMathAtom(type: .ordinary, value: \"\\u{03F0}\") to the supportedLatexSymbols dictionary. This represents the variant kappa ϰ used in mathematics. Following the pattern of existing Greek variants like \\varepsilon and \\vartheta, the atom type should be .ordinary to avoid auto-italicization.",
            "status": "done",
            "testStrategy": "Write unit test that builds \\varkappa and verifies atom type is .ordinary and nucleus is ϰ (U+03F0).",
            "parentId": "undefined",
            "updatedAt": "2026-01-10T13:18:16.905Z"
          },
          {
            "id": 14,
            "title": "Fix varsigma mapping and add digamma Greek letter",
            "description": "Fix the incorrect \\varsigma mapping (currently maps to rho) and add the \\digamma symbol for the Greek letter digamma to supportedLatexSymbols.",
            "dependencies": [
              1
            ],
            "details": "Fix entry \"varsigma\" to use correct value \"\\u{03C2}\" (final sigma ς) instead of current \"\\u{03C1}\" (rho). Add new entry \"digamma\" : MTMathAtom(type: .variable, value: \"\\u{03DD}\") for the archaic Greek letter digamma ϝ. The varsigma should use .variable type to match other Greek letters.",
            "status": "done",
            "testStrategy": "Write unit tests that build \\varsigma and \\digamma, verifying atom types and nuclei. Verify varsigma no longer outputs rho.",
            "parentId": "undefined",
            "updatedAt": "2026-01-10T13:18:23.251Z"
          },
          {
            "id": 15,
            "title": "Add varnothing symbol to supportedLatexSymbols",
            "description": "Add the \\varnothing symbol mapping for the variant empty set to the supportedLatexSymbols dictionary in MTMathAtomFactory.swift.",
            "dependencies": [
              1
            ],
            "details": "Add entry \"varnothing\" : MTMathAtom(type: .ordinary, value: \"\\u{2205}\") to the supportedLatexSymbols dictionary. Note: In standard LaTeX, \\varnothing renders the slashed zero style empty set. Using U+2205 (∅) is acceptable as it's the same codepoint as emptyset but the variant rendering depends on font. Alternatively use U+29B0 (⦰) for a distinct variant if needed.",
            "status": "done",
            "testStrategy": "Write unit test that builds \\varnothing and verifies atom type is .ordinary with correct nucleus. Test that it differs visually from \\emptyset when rendered.",
            "parentId": "undefined",
            "updatedAt": "2026-01-10T13:18:30.232Z"
          },
          {
            "id": 16,
            "title": "Fix square symbol and add Box to supportedLatexSymbols",
            "description": "Change \\square from placeholder to actual square symbol and add \\Box as a synonym or distinct symbol to supportedLatexSymbols.",
            "dependencies": [
              1
            ],
            "details": "The current \"square\" entry creates a placeholder atom. Change it to \"square\" : MTMathAtom(type: .ordinary, value: \"\\u{25A1}\") for the white square □ symbol. Also add \"Box\" : MTMathAtom(type: .ordinary, value: \"\\u{25A1}\") as an alias. Alternatively, add Box as an alias in the aliases dictionary. Consider impact on placeholder() function which uses square.",
            "status": "done",
            "testStrategy": "Write unit tests that build \\square and \\Box, verifying both produce ordinary atoms with □ nucleus. Ensure placeholder functionality still works via placeholderSquareRoot() method.",
            "parentId": "undefined",
            "updatedAt": "2026-01-10T13:18:36.924Z"
          },
          {
            "id": 17,
            "title": "Add measuredangle symbol to supportedLatexSymbols",
            "description": "Add the \\measuredangle symbol mapping for the measured angle symbol to the supportedLatexSymbols dictionary in MTMathAtomFactory.swift.",
            "dependencies": [
              1
            ],
            "details": "Add entry \"measuredangle\" : MTMathAtom(type: .ordinary, value: \"\\u{2221}\") to the supportedLatexSymbols dictionary. This represents the measured angle ∡ symbol used in geometry. The atom type should be .ordinary like the existing \\angle symbol.",
            "status": "done",
            "testStrategy": "Write unit test that builds \\measuredangle and verifies atom type is .ordinary and nucleus is ∡ (U+2221). Compare with existing \\angle test pattern.",
            "parentId": "undefined",
            "updatedAt": "2026-01-10T13:18:43.046Z"
          },
          {
            "id": 18,
            "title": "Add beth and gimel Hebrew letters to supportedLatexSymbols",
            "description": "Add the \\beth and \\gimel symbol mappings for Hebrew letters used in set theory to the supportedLatexSymbols dictionary in MTMathAtomFactory.swift.",
            "dependencies": [
              1
            ],
            "details": "Add entries \"beth\" : MTMathAtom(type: .ordinary, value: \"\\u{2136}\") and \"gimel\" : MTMathAtom(type: .ordinary, value: \"\\u{2137}\") to the supportedLatexSymbols dictionary. These represent the Hebrew letters ℶ (beth) and ℷ (gimel) used for transfinite cardinal numbers. Both should use atom type .ordinary like the existing \\aleph symbol.",
            "status": "done",
            "testStrategy": "Write unit tests that build \\beth and \\gimel and verify atom types are .ordinary with correct Unicode nuclei (U+2136 and U+2137). Compare with existing \\aleph implementation.",
            "parentId": "undefined",
            "updatedAt": "2026-01-10T13:18:48.327Z"
          },
          {
            "id": 19,
            "title": "Add comprehensive unit tests for all Priority 1 symbols",
            "description": "Create a comprehensive test suite in MTMathListBuilderTests.swift that tests all newly added Priority 1 symbols for correct parsing, atom types, and LaTeX roundtrip.",
            "dependencies": [
              2,
              3,
              4,
              5,
              6,
              7,
              8,
              9,
              10,
              11,
              12,
              13,
              14,
              15,
              16,
              17,
              18
            ],
            "details": "Add a new test method testPriority1Symbols() that tests each new symbol: blackboard bold letters (N,Z,Q,R,C), slanted inequalities (leqslant, geqslant), set relations (preceq, succeq), arrows (longmapsto), operators (diamond, bowtie, vdash, dashv), Greek variants (varkappa, digamma, fixed varsigma), and misc symbols (varnothing, square, Box, measuredangle, beth, gimel). Test that MTMathListBuilder.build(fromString:) produces correct MTMathList with proper atom types and nuclei. Test that MTMathListBuilder.mathListToString() produces expected LaTeX output.",
            "status": "done",
            "testStrategy": "Run swift test --filter testPriority1Symbols to verify all symbols parse correctly with proper types and roundtrip through LaTeX serialization.",
            "parentId": "undefined",
            "updatedAt": "2026-01-10T13:18:54.434Z"
          },
          {
            "id": 20,
            "title": "Verify font support and run full test suite",
            "description": "Verify that all bundled math fonts support the newly added symbols and run the complete test suite to ensure no regressions.",
            "dependencies": [
              19
            ],
            "details": "Check the font .plist files in MathBundle to verify glyph support for all new Unicode code points. Some symbols may not render correctly in certain fonts. Run swift test to execute all tests and ensure the new symbols work correctly without breaking existing functionality. Check for any symbol conflicts with existing mappings. Document any font limitations in CLAUDE.md.",
            "status": "done",
            "testStrategy": "Run swift test for full test suite. Create a visual test if possible to render each symbol with each bundled font and verify appearance. Document any font compatibility issues.",
            "parentId": "undefined",
            "updatedAt": "2026-01-10T13:19:00.294Z"
          }
        ],
        "updatedAt": "2026-01-10T13:19:00.294Z"
      },
      {
        "id": "2",
        "title": "Implement \\mathbb{} Command for Blackboard Bold",
        "description": "Add command parsing for \\mathbb{} in MTMathListBuilder.swift. Wire up the existing mathBB() function in MTUnicode.swift to render blackboard bold characters (N, Z, Q, R, C, etc.)",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          "1"
        ],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2026-01-10T13:17:07.628Z"
      },
      {
        "id": "3",
        "title": "Implement Manual Delimiter Sizing Commands",
        "description": "Add support for \\big, \\Big, \\bigg, \\Bigg delimiter sizing commands. Parse commands in MTMathListBuilder.swift and apply size multipliers (1.2x, 1.8x, 2.4x, 3.0x) in MTTypesetter.swift",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2026-01-10T13:32:48.760Z"
      },
      {
        "id": "4",
        "title": "Add Negated Relation Symbols (amssymb equivalents)",
        "description": "Extend notCombinations dictionary and add direct symbol mappings for negated relations: nless, ngtr, nleq, ngeq, nprec, nsucc, ncong, nsim, nvdash, nvDash, ntriangleleft, ntriangleright, subsetneq, supsetneq, and ~30 more amssymb negated relations",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          "1"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2026-01-10T14:10:41.698Z"
      },
      {
        "id": "5",
        "title": "Implement \\operatorname{} Command",
        "description": "Add support for \\operatorname{} to render custom operators in roman (upright) font within math mode. Parse in MTMathListBuilder.swift and render text appropriately",
        "details": "",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": "6",
        "title": "Implement \\boldsymbol{} Command",
        "description": "Add support for \\boldsymbol{} to render bold Greek letters and symbols. Parse in MTMathListBuilder.swift and apply bold font variant selection",
        "details": "",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [
          "1"
        ],
        "priority": "low",
        "subtasks": []
      },
      {
        "id": "7",
        "title": "Add Binary Operator Symbols",
        "description": "Add missing binary operators to supportedLatexSymbols: triangleleft, triangleright, bigtriangleup, bigtriangledown, bigcirc, uplus",
        "details": "",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [
          "1"
        ],
        "priority": "low",
        "subtasks": []
      },
      {
        "id": "8",
        "title": "Add Corner Bracket Delimiters",
        "description": "Add corner bracket delimiters to supportedLatexSymbols and delimiters dictionary: ulcorner, urcorner, llcorner, lrcorner",
        "details": "",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [
          "1"
        ],
        "priority": "low",
        "subtasks": []
      },
      {
        "id": "9",
        "title": "Add Missing Trigonometric Functions",
        "description": "Add missing trig functions to supportedLatexSymbols: arccsc, arcsec, arccot, csch, sech, and hyperbolic inverses",
        "details": "",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [],
        "priority": "low",
        "subtasks": []
      },
      {
        "id": "10",
        "title": "Create Comprehensive Test Suite for New Symbols",
        "description": "Create test cases for all newly added symbols, commands, and features. Include visual regression tests comparing rendered output against expected LaTeX rendering",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          "1",
          "2",
          "3",
          "4"
        ],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2026-01-10T14:50:53.545Z"
      },
      {
        "id": "11",
        "title": "Implement Dirac Notation Operators (\\bra{}, \\ket{}, \\braket{})",
        "description": "Add support for LaTeX physics package Dirac notation commands: \\bra{} renders ⟨content|, \\ket{} renders |content⟩, and \\braket{}{} renders ⟨phi|psi⟩ for quantum physics applications.",
        "details": "**Implementation Location**: `Sources/SwiftMath/MathRender/MTMathListBuilder.swift` in the `atomForCommand()` method\n\n**Step 1: Add \\bra{} command handler**\nIn `atomForCommand()`, add a case for \"bra\":\n```swift\n} else if command == \"bra\" {\n    // \\bra{psi} -> <psi|\n    let inner = MTInner()\n    inner.leftBoundary = MTMathAtomFactory.boundary(forDelimiter: \"langle\")\n    inner.rightBoundary = MTMathAtomFactory.boundary(forDelimiter: \"vert\")\n    inner.innerList = self.buildInternal(true)\n    return inner\n```\n\n**Step 2: Add \\ket{} command handler**\nAdd a case for \"ket\":\n```swift\n} else if command == \"ket\" {\n    // \\ket{psi} -> |psi>\n    let inner = MTInner()\n    inner.leftBoundary = MTMathAtomFactory.boundary(forDelimiter: \"vert\")\n    inner.rightBoundary = MTMathAtomFactory.boundary(forDelimiter: \"rangle\")\n    inner.innerList = self.buildInternal(true)\n    return inner\n```\n\n**Step 3: Add \\braket{}{} command handler**\nAdd a case for \"braket\" that parses two arguments:\n```swift\n} else if command == \"braket\" {\n    // \\braket{phi}{psi} -> <phi|psi>\n    let inner = MTInner()\n    inner.leftBoundary = MTMathAtomFactory.boundary(forDelimiter: \"langle\")\n    inner.rightBoundary = MTMathAtomFactory.boundary(forDelimiter: \"rangle\")\n    \n    // Build inner list: first argument + | + second argument\n    let innerList = MTMathList()\n    \n    // Parse first argument (phi)\n    if let firstArg = self.buildInternal(true) {\n        innerList.append(firstArg)\n    }\n    \n    // Add the vertical bar separator\n    let vert = MTMathAtom(type: .ordinary, value: \"|\")\n    innerList.add(vert)\n    \n    // Parse second argument (psi)\n    if let secondArg = self.buildInternal(true) {\n        innerList.append(secondArg)\n    }\n    \n    inner.innerList = innerList\n    return inner\n```\n\n**Step 4: Add LaTeX-to-string conversion support**\nIn `mathListToString()` method, add handling for converting MTInner atoms with Dirac notation delimiters back to their LaTeX command forms. Check for the specific boundary combinations:\n- langle + vert → \\bra{}\n- vert + rangle → \\ket{}\n- langle + rangle with internal vert → \\braket{}{}\n\n**Unicode Characters Used**:\n- Left angle bracket (langle): U+2329 (⟨)\n- Right angle bracket (rangle): U+232A (⟩)\n- Vertical bar (vert): | (ASCII 0x7C)\n\n**Existing Infrastructure**:\n- `MTMathAtomFactory.boundary(forDelimiter:)` already supports \"langle\", \"rangle\", and \"vert\"\n- `MTInner` class handles bounded expressions with leftBoundary and rightBoundary\n- Auto-sizing delimiters work automatically with MTInner\n\n**Note**: The delimiters will auto-size to match the content height, consistent with existing \\left...\\right behavior. If fixed-size delimiters are preferred, consider whether to support variants like \\Bra{}, \\Ket{} for larger sizes.",
        "testStrategy": "**Unit Tests** (add to `Tests/SwiftMathTests/MTMathListBuilderTests.swift`):\n\n1. **testBraCommand**: Parse `\\bra{\\psi}` and verify:\n   - Returns MTInner atom\n   - leftBoundary has nucleus \"⟨\" (U+2329)\n   - rightBoundary has nucleus \"|\"\n   - innerList contains the variable ψ\n\n2. **testKetCommand**: Parse `\\ket{\\psi}` and verify:\n   - Returns MTInner atom\n   - leftBoundary has nucleus \"|\"\n   - rightBoundary has nucleus \"⟩\" (U+232A)\n   - innerList contains the variable ψ\n\n3. **testBraketCommand**: Parse `\\braket{\\phi}{\\psi}` and verify:\n   - Returns MTInner atom\n   - leftBoundary has nucleus \"⟨\"\n   - rightBoundary has nucleus \"⟩\"\n   - innerList contains: φ, |, ψ (in order)\n\n4. **testBraWithExpression**: Parse `\\bra{n+1}` and verify innerList contains the complete expression\n\n5. **testKetWithSubscript**: Parse `\\ket{\\psi_0}` and verify subscript is preserved\n\n6. **testBraketInEquation**: Parse `\\braket{\\phi}{\\psi} = \\int \\phi^* \\psi dx` and verify the complete expression parses correctly\n\n7. **testNestedDiracNotation**: Parse `\\bra{\\psi}\\ket{\\phi}` to ensure multiple Dirac notations work together\n\n8. **testMathListToStringBra**: Build `\\bra{\\psi}`, convert back to LaTeX, verify output\n\n**Visual Render Tests** (add to visual test suite):\n- Create test images showing rendered \\bra{}, \\ket{}, \\braket{} with various contents\n- Compare with expected quantum physics notation appearance\n- Test with Greek letters, subscripts, and complex expressions",
        "status": "done",
        "dependencies": [
          "3"
        ],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2026-01-10T23:26:59.270Z"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2026-01-10T23:26:59.271Z",
      "taskCount": 11,
      "completedCount": 6,
      "tags": [
        "master"
      ]
    }
  },
  "future": {
    "tasks": [
      {
        "id": 1,
        "title": "Implement physics package support for Dirac notation, absolute value/norms, vector notation, and derivatives",
        "description": "Add LaTeX physics package commands including \\bra{}, \\ket{}, \\braket{} for Dirac notation, \\abs{}, \\norm{} for absolute value and norms, \\vb{}, \\va{} for vector notation, and \\dv{}{}, \\pdv{}{} for ordinary and partial derivatives.",
        "details": "## Implementation Overview\n\nThis task implements a subset of the LaTeX physics package, following the established patterns in MTMathListBuilder.swift and MTMathAtomFactory.swift.\n\n## 1. Dirac Notation Commands\n\n### Commands to implement:\n- `\\bra{content}` → renders as ⟨content|\n- `\\ket{content}` → renders as |content⟩\n- `\\braket{a}{b}` → renders as ⟨a|b⟩\n- `\\Bra{content}`, `\\Ket{content}`, `\\Braket{a}{b}` → auto-sizing variants using \\left/\\right\n\n### Implementation approach:\nIn `MTMathListBuilder.atomForCommand()`, add cases for these commands that:\n1. Create an `MTInner` with appropriate left/right boundaries (⟨ = U+27E8, ⟩ = U+27E9, | = |)\n2. Parse one or two braced arguments using `buildInternal(true)`\n3. For braket, combine arguments with a | separator\n\nExample pattern (similar to existing `\\pmod` implementation at line 932-955):\n```swift\n} else if command == \"ket\" {\n    let inner = MTInner()\n    inner.leftBoundary = MTMathAtomFactory.boundary(forDelimiter: \"|\")\n    inner.rightBoundary = MTMathAtomFactory.boundary(forDelimiter: \"rangle\")\n    inner.innerList = self.buildInternal(true)\n    return inner\n```\n\n## 2. Absolute Value and Norm Commands\n\n### Commands to implement:\n- `\\abs{content}` → renders as |content|\n- `\\norm{content}` → renders as ‖content‖ (double vertical bars, U+2016)\n- `\\Abs{content}`, `\\Norm{content}` → auto-sizing variants\n\n### Implementation approach:\nCreate `MTInner` atoms with:\n- For \\abs: left and right boundaries as \"|\"\n- For \\norm: left and right boundaries as \"||\" (maps to U+2016 in delimiters dictionary)\n\n## 3. Vector Notation Commands\n\n### Commands to implement:\n- `\\vb{x}` → bold vector: equivalent to `\\mathbf{x}`\n- `\\va{x}` → bold vector with arrow: equivalent to `\\vec{\\mathbf{x}}`\n- `\\vu{x}` → unit vector (hat accent): equivalent to `\\hat{\\mathbf{x}}`\n\n### Implementation approach:\n1. For `\\vb{}`: Set fontStyle to `.bold` on the parsed content, similar to existing font style handling (lines 473-490)\n2. For `\\va{}`: Create an `MTAccent` with vec accent (U+20D7) and bold inner content\n3. For `\\vu{}`: Create an `MTAccent` with hat accent (U+0302) and bold inner content\n\n## 4. Derivative Commands\n\n### Commands to implement:\n- `\\dv{f}{x}` → ordinary derivative: df/dx\n- `\\dv{x}` → shorthand: d/dx\n- `\\pdv{f}{x}` → partial derivative: ∂f/∂x\n- `\\pdv{x}` → shorthand: ∂/∂x\n\n### Implementation approach:\n1. Parse one or two braced arguments\n2. Create an `MTFraction` with:\n   - Numerator: \"d\" (or ∂ for partial) + first arg (if two args) or empty\n   - Denominator: \"d\" (or ∂) + last arg\n3. Use existing fraction rendering infrastructure\n\nExample:\n```swift\n} else if command == \"dv\" {\n    let frac = MTFraction()\n    let firstArg = self.buildInternal(true)\n    \n    // Check if there's a second argument\n    skipSpaces()\n    if hasCharacters && string[currentCharIndex] == \"{\" {\n        // Two arguments: df/dx format\n        let secondArg = self.buildInternal(true)\n        let dSymbol = MTMathAtom(type: .ordinary, value: \"d\")\n        let numerator = MTMathList()\n        numerator.add(dSymbol)\n        if let first = firstArg { numerator.append(first) }\n        frac.numerator = numerator\n        \n        let denominator = MTMathList()\n        denominator.add(MTMathAtom(type: .ordinary, value: \"d\"))\n        if let second = secondArg { denominator.append(second) }\n        frac.denominator = denominator\n    } else {\n        // One argument: d/dx format\n        frac.numerator = MTMathList(atom: MTMathAtom(type: .ordinary, value: \"d\"))\n        let denominator = MTMathList()\n        denominator.add(MTMathAtom(type: .ordinary, value: \"d\"))\n        if let first = firstArg { denominator.append(first) }\n        frac.denominator = denominator\n    }\n    return frac\n}\n```\n\nFor partial derivatives, use U+2202 (∂) instead of \"d\".\n\n## File Modifications Required\n\n1. **MTMathListBuilder.swift** (lines ~748-1013):\n   - Add cases in `atomForCommand()` for all new commands\n\n2. **MTMathAtomFactory.swift** (optional enhancements):\n   - Could add helper methods like `partialDerivative()` for consistency\n   - Add \"partial\" to supportedLatexSymbols if not present (U+2202)\n\n3. **Add reverse conversion support** in `mathListToString()` (lines ~558-732):\n   - Handle conversion back to LaTeX for these commands\n\n## Unicode Characters Needed\n\n- ⟨ (left angle bracket): U+27E8 - already in delimiters as \"langle\"\n- ⟩ (right angle bracket): U+27E9 - already in delimiters as \"rangle\"\n- ‖ (double vertical bar): U+2016 - already in delimiters as \"||\" or \"Vert\"\n- ∂ (partial derivative): U+2202 or U+1D715 - check supportedLatexSymbols\n\n## Considerations\n\n- Follow existing code patterns exactly (use NSLock for thread safety if adding to shared dictionaries)\n- Capital variants (Bra, Ket, Abs, Norm) should use auto-sizing delimiters (similar to \\left/\\right behavior)\n- All commands should gracefully handle missing arguments with appropriate error messages",
        "testStrategy": "## Unit Tests (in MTMathListBuilderTests.swift)\n\n### 1. Dirac Notation Tests\n```swift\nfunc testBraKet() throws {\n    // Test \\bra{}\n    var error: NSError? = nil\n    var list = MTMathListBuilder.build(fromString: \"\\\\bra{\\\\psi}\", error: &error)\n    XCTAssertNil(error)\n    XCTAssertNotNil(list)\n    XCTAssertEqual(list!.atoms.count, 1)\n    let bra = list!.atoms[0] as? MTInner\n    XCTAssertNotNil(bra)\n    XCTAssertEqual(bra?.leftBoundary?.nucleus, \"⟨\")\n    XCTAssertEqual(bra?.rightBoundary?.nucleus, \"|\")\n    \n    // Test \\ket{}\n    list = MTMathListBuilder.build(fromString: \"\\\\ket{\\\\phi}\", error: &error)\n    let ket = list!.atoms[0] as? MTInner\n    XCTAssertEqual(ket?.leftBoundary?.nucleus, \"|\")\n    XCTAssertEqual(ket?.rightBoundary?.nucleus, \"⟩\")\n    \n    // Test \\braket{}{} \n    list = MTMathListBuilder.build(fromString: \"\\\\braket{\\\\psi}{\\\\phi}\", error: &error)\n    XCTAssertNotNil(list)\n    // Verify structure contains ⟨ψ|φ⟩\n}\n\nfunc testBraKetCapitalVariants() throws {\n    // Test auto-sizing variants\n    let list = MTMathListBuilder.build(fromString: \"\\\\Ket{\\\\frac{a}{b}}\")\n    XCTAssertNotNil(list)\n}\n```\n\n### 2. Absolute Value and Norm Tests\n```swift\nfunc testAbsAndNorm() throws {\n    // Test \\abs{}\n    var error: NSError? = nil\n    var list = MTMathListBuilder.build(fromString: \"\\\\abs{x}\", error: &error)\n    XCTAssertNil(error)\n    let abs = list!.atoms[0] as? MTInner\n    XCTAssertEqual(abs?.leftBoundary?.nucleus, \"|\")\n    XCTAssertEqual(abs?.rightBoundary?.nucleus, \"|\")\n    \n    // Test \\norm{}\n    list = MTMathListBuilder.build(fromString: \"\\\\norm{v}\", error: &error)\n    let norm = list!.atoms[0] as? MTInner\n    XCTAssertEqual(norm?.leftBoundary?.nucleus, \"‖\")\n    XCTAssertEqual(norm?.rightBoundary?.nucleus, \"‖\")\n}\n```\n\n### 3. Vector Notation Tests\n```swift\nfunc testVectorNotation() throws {\n    // Test \\vb{} - bold vector\n    var error: NSError? = nil\n    var list = MTMathListBuilder.build(fromString: \"\\\\vb{x}\", error: &error)\n    XCTAssertNil(error)\n    XCTAssertNotNil(list)\n    // Verify fontStyle is bold\n    \n    // Test \\va{} - bold with arrow\n    list = MTMathListBuilder.build(fromString: \"\\\\va{x}\", error: &error)\n    XCTAssertNil(error)\n    let accent = list!.atoms[0] as? MTAccent\n    XCTAssertNotNil(accent)\n    XCTAssertEqual(accent?.nucleus, \"\\u{20D7}\") // vec arrow\n    \n    // Test \\vu{} - unit vector with hat\n    list = MTMathListBuilder.build(fromString: \"\\\\vu{x}\", error: &error)\n    let hatAccent = list!.atoms[0] as? MTAccent\n    XCTAssertEqual(hatAccent?.nucleus, \"\\u{0302}\") // hat\n}\n```\n\n### 4. Derivative Tests\n```swift\nfunc testDerivatives() throws {\n    // Test \\dv{f}{x} - two arguments\n    var error: NSError? = nil\n    var list = MTMathListBuilder.build(fromString: \"\\\\dv{f}{x}\", error: &error)\n    XCTAssertNil(error)\n    let frac = list!.atoms[0] as? MTFraction\n    XCTAssertNotNil(frac)\n    XCTAssertTrue(frac!.hasRule)\n    // Verify numerator contains \"df\" and denominator contains \"dx\"\n    \n    // Test \\dv{x} - one argument\n    list = MTMathListBuilder.build(fromString: \"\\\\dv{x}\", error: &error)\n    XCTAssertNil(error)\n    // Verify d/dx format\n    \n    // Test \\pdv{f}{x} - partial derivative\n    list = MTMathListBuilder.build(fromString: \"\\\\pdv{f}{x}\", error: &error)\n    XCTAssertNil(error)\n    // Verify ∂f/∂x format\n    \n    // Test nested derivatives\n    list = MTMathListBuilder.build(fromString: \"\\\\dv{\\\\dv{f}{x}}{y}\", error: &error)\n    XCTAssertNil(error)\n}\n```\n\n### 5. Error Handling Tests\n```swift\nfunc testPhysicsCommandErrors() throws {\n    // Test missing argument for \\ket\n    var error: NSError? = nil\n    let list = MTMathListBuilder.build(fromString: \"\\\\ket\", error: &error)\n    // Should handle gracefully (empty innerList or error)\n    \n    // Test \\braket with only one argument\n    let list2 = MTMathListBuilder.build(fromString: \"\\\\braket{a}\", error: &error)\n    // Should handle as single-argument variant\n}\n```\n\n### 6. Visual Render Tests (in MathImageTests.swift or new file)\n```swift\nfunc testPhysicsPackageRendering() throws {\n    // Test visual rendering of all physics commands\n    let testCases = [\n        \"\\\\bra{\\\\psi}\",\n        \"\\\\ket{\\\\phi}\",\n        \"\\\\braket{\\\\psi}{\\\\phi}\",\n        \"\\\\abs{x}\",\n        \"\\\\norm{v}\",\n        \"\\\\vb{F}\",\n        \"\\\\va{v}\",\n        \"\\\\vu{n}\",\n        \"\\\\dv{f}{x}\",\n        \"\\\\pdv{f}{x}\",\n        \"\\\\dv{y}\" // one-arg form\n    ]\n    \n    for latex in testCases {\n        let image = MTMathImage(latex: latex, fontSize: 20)\n        XCTAssertNotNil(image.image, \"Should render: \\(latex)\")\n        // Optionally save images for visual inspection\n    }\n}\n```\n\n### 7. Round-trip Tests\n```swift\nfunc testPhysicsCommandRoundTrip() throws {\n    let testCases = [\"\\\\abs{x}\", \"\\\\norm{v}\", \"\\\\dv{f}{x}\"]\n    \n    for original in testCases {\n        let list = MTMathListBuilder.build(fromString: original)\n        let reconstructed = MTMathListBuilder.mathListToString(list)\n        // Verify reconstructed LaTeX produces equivalent math list\n    }\n}\n```\n\n## Manual Testing\n1. Build the project with `swift build` - should compile without errors\n2. Run `swift test` - all new tests should pass\n3. Run `swift test --filter testPhysicsPackageRendering` to verify visual output\n4. Compare rendered output with standard LaTeX physics package output",
        "status": "pending",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement mhchem package support for chemical formulas",
        "description": "Add \\ce{} command for chemical formulas with proper subscript handling (H2O), ion notation (Ca^2+), and reaction arrows (->, <->, <=>, etc.) following the mhchem LaTeX package conventions.",
        "details": "## Implementation Overview\n\nThis task implements the mhchem package's `\\ce{}` command for rendering chemical formulas, following the established patterns in `MTMathListBuilder.swift` and `MTMathAtomFactory.swift`.\n\n## 1. Chemical Formula Parsing in \\ce{}\n\n### Core Functionality:\nThe `\\ce{}` command needs a custom parser that interprets chemical notation differently from standard LaTeX math mode:\n\n1. **Automatic subscripts for numbers after elements**: `H2O` → H₂O (numbers after letters become subscripts)\n2. **Superscripts for charges**: `Ca^2+` or `Ca^{2+}` → Ca²⁺\n3. **Reaction arrows**: `->`, `<-`, `<->`, `<=>` → appropriate Unicode arrows\n4. **Upright text**: Chemical element symbols should be upright (roman), not italic\n5. **Coefficient handling**: Numbers at the start remain as coefficients: `2H2O`\n\n### Implementation approach in `MTMathListBuilder.swift`:\n\nAdd handling for `\\ce` command in `atomForCommand()` (around line 748):\n\n```swift\n} else if command == \"ce\" {\n    // Chemical equation command - parse content with chemical notation rules\n    return self.parseChemicalFormula()\n}\n```\n\nAdd new method `parseChemicalFormula()`:\n\n```swift\nmutating func parseChemicalFormula() -> MTMathAtom? {\n    // Expect opening brace\n    if !self.expectCharacter(\"{\") {\n        self.setError(.characterNotFound, message: \"Missing { for \\\\ce\")\n        return nil\n    }\n    \n    let list = MTMathList()\n    var currentElement = \"\"\n    var isParsingNumber = false\n    var numberBuffer = \"\"\n    \n    while self.hasCharacters {\n        let char = self.getNextCharacter()\n        \n        if char == \"}\" {\n            // End of \\ce{} - flush any pending content\n            flushChemicalContent(&list, element: &currentElement, number: &numberBuffer, isSubscript: &isParsingNumber)\n            break\n        }\n        \n        // Handle reaction arrows: ->, <-, <->, <=>\n        if char == \"-\" || char == \"<\" || char == \"=\" {\n            flushChemicalContent(&list, element: &currentElement, number: &numberBuffer, isSubscript: &isParsingNumber)\n            if let arrow = parseChemicalArrow(startingWith: char) {\n                list.add(arrow)\n            }\n            continue\n        }\n        \n        // Handle superscripts for charges (^2+ or ^{2+})\n        if char == \"^\" {\n            flushChemicalContent(&list, element: &currentElement, number: &numberBuffer, isSubscript: &isParsingNumber)\n            if let charge = parseChemicalCharge() {\n                // Attach as superscript to previous atom\n                if let prevAtom = list.atoms.last {\n                    prevAtom.superScript = charge\n                }\n            }\n            continue\n        }\n        \n        // Parse element names (uppercase followed by optional lowercase)\n        if char.isUppercase {\n            flushChemicalContent(&list, element: &currentElement, number: &numberBuffer, isSubscript: &isParsingNumber)\n            currentElement = String(char)\n            isParsingNumber = false\n        } else if char.isLowercase && !currentElement.isEmpty {\n            currentElement.append(char)\n        } else if char.isNumber {\n            if currentElement.isEmpty && list.atoms.isEmpty {\n                // Leading coefficient\n                let atom = MTMathAtom(type: .number, value: String(char))\n                atom.fontStyle = .roman\n                list.add(atom)\n            } else {\n                // Subscript number\n                numberBuffer.append(char)\n                isParsingNumber = true\n            }\n        } else if char == \"+\" || char == \"-\" {\n            // Standalone charge symbol\n            flushChemicalContent(&list, element: &currentElement, number: &numberBuffer, isSubscript: &isParsingNumber)\n            let atom = MTMathAtom(type: .ordinary, value: char == \"+\" ? \"+\" : \"−\")\n            atom.fontStyle = .roman\n            list.add(atom)\n        } else if char == \" \" {\n            // Space in chemical formula - add thin space\n            flushChemicalContent(&list, element: &currentElement, number: &numberBuffer, isSubscript: &isParsingNumber)\n            list.add(MTMathSpace(space: 3))\n        } else if char == \"(\" || char == \")\" || char == \"[\" || char == \"]\" {\n            flushChemicalContent(&list, element: &currentElement, number: &numberBuffer, isSubscript: &isParsingNumber)\n            let type: MTMathAtomType = (char == \"(\" || char == \"[\") ? .open : .close\n            let atom = MTMathAtom(type: type, value: String(char))\n            atom.fontStyle = .roman\n            list.add(atom)\n        }\n    }\n    \n    let inner = MTInner()\n    inner.innerList = list\n    return inner\n}\n```\n\n## 2. Chemical Arrows in `MTMathAtomFactory.swift`\n\nAdd chemical reaction arrow symbols to `supportedLatexSymbols` dictionary (around line 230):\n\n```swift\n// Chemical reaction arrows (mhchem)\n\"rightarrow\" : MTMathAtom(type: .relation, value: \"\\u{2192}\"),  // Already exists\n\"longrightarrow\" : MTMathAtom(type: .relation, value: \"\\u{27F6}\"),  // Already exists\n\"equilibrium\" : MTMathAtom(type: .relation, value: \"\\u{21CC}\"),     // ⇌ reversible reaction\n\"rightleftharpoons\" : MTMathAtom(type: .relation, value: \"\\u{21CC}\"),\n\"leftrightarrow\" : MTMathAtom(type: .relation, value: \"\\u{2194}\"),  // Already exists\n```\n\n## 3. Helper Methods for Chemical Parsing\n\nAdd to `MTMathListBuilder.swift`:\n\n```swift\nmutating func parseChemicalArrow(startingWith first: Character) -> MTMathAtom? {\n    var arrowStr = String(first)\n    \n    while hasCharacters {\n        let next = getNextCharacter()\n        if next == \">\" || next == \"-\" || next == \"=\" || next == \"<\" {\n            arrowStr.append(next)\n        } else {\n            unlookCharacter()\n            break\n        }\n    }\n    \n    // Map arrow strings to Unicode symbols\n    let arrowMap: [String: String] = [\n        \"->\": \"\\u{2192}\",      // → rightarrow\n        \"<-\": \"\\u{2190}\",      // ← leftarrow\n        \"<->\": \"\\u{2194}\",     // ↔ leftrightarrow\n        \"<=>\": \"\\u{21CC}\",     // ⇌ equilibrium\n        \"<=>>\": \"\\u{21C1}\",    // Forward favored equilibrium (approximation)\n        \"<<=>\": \"\\u{21C0}\",    // Reverse favored equilibrium (approximation)\n    ]\n    \n    if let unicode = arrowMap[arrowStr] {\n        let atom = MTMathAtom(type: .relation, value: unicode)\n        atom.fontStyle = .roman\n        return atom\n    }\n    return nil\n}\n\nmutating func parseChemicalCharge() -> MTMathList? {\n    let chargeList = MTMathList()\n    \n    if expectCharacter(\"{\") {\n        // Parse braced charge like ^{2+}\n        while hasCharacters {\n            let char = getNextCharacter()\n            if char == \"}\" { break }\n            let atom = MTMathAtom(type: .ordinary, value: String(char))\n            atom.fontStyle = .roman\n            chargeList.add(atom)\n        }\n    } else if hasCharacters {\n        // Single character charge like ^+\n        let char = getNextCharacter()\n        if char.isNumber || char == \"+\" || char == \"-\" {\n            let atom = MTMathAtom(type: .ordinary, value: String(char))\n            atom.fontStyle = .roman\n            chargeList.add(atom)\n            // Check for following + or -\n            if hasCharacters {\n                let next = getNextCharacter()\n                if next == \"+\" || next == \"-\" {\n                    let signAtom = MTMathAtom(type: .ordinary, value: String(next))\n                    signAtom.fontStyle = .roman\n                    chargeList.add(signAtom)\n                } else {\n                    unlookCharacter()\n                }\n            }\n        } else {\n            unlookCharacter()\n        }\n    }\n    \n    return chargeList.atoms.isEmpty ? nil : chargeList\n}\n\nmutating func flushChemicalContent(_ list: inout MTMathList, element: inout String, number: inout String, isSubscript: inout Bool) {\n    if !element.isEmpty {\n        let atom = MTMathAtom(type: .ordinary, value: element)\n        atom.fontStyle = .roman\n        \n        if !number.isEmpty {\n            let subscriptList = MTMathList()\n            for digit in number {\n                let digitAtom = MTMathAtom(type: .number, value: String(digit))\n                digitAtom.fontStyle = .roman\n                subscriptList.add(digitAtom)\n            }\n            atom.subScript = subscriptList\n            number = \"\"\n        }\n        \n        list.add(atom)\n        element = \"\"\n    } else if !number.isEmpty {\n        // Standalone number (coefficient)\n        for digit in number {\n            let digitAtom = MTMathAtom(type: .number, value: String(digit))\n            digitAtom.fontStyle = .roman\n            list.add(digitAtom)\n        }\n        number = \"\"\n    }\n    isSubscript = false\n}\n```\n\n## 4. Files to Modify\n\n1. **MTMathListBuilder.swift** (Sources/SwiftMath/MathRender/):\n   - Add `\\ce` command handling in `atomForCommand()` method (~line 968)\n   - Add `parseChemicalFormula()` method\n   - Add `parseChemicalArrow()` helper method\n   - Add `parseChemicalCharge()` helper method\n   - Add `flushChemicalContent()` helper method\n\n2. **MTMathAtomFactory.swift** (Sources/SwiftMath/MathRender/):\n   - Add equilibrium arrow symbol `\\u{21CC}` to `supportedLatexSymbols` if not already present\n\n## 5. Edge Cases to Handle\n\n- Nested parentheses: `Ca(OH)2`\n- Hydrates: `CuSO4·5H2O` (middle dot handling)\n- State indicators: `(s)`, `(l)`, `(g)`, `(aq)` - should remain upright\n- Isotopes: `^{14}C` or `^14C` for carbon-14\n- Complex ions in brackets: `[Cu(NH3)4]^{2+}`\n- Decimal coefficients: `0.5H2O`\n- Electron notation: `e^-`\n\n## 6. Dependencies\n\nThis task depends on Task 1 (physics package support) only if shared infrastructure is created there. Otherwise, it can be implemented independently as it follows the same established patterns.",
        "testStrategy": "## Unit Tests (in MTMathListBuilderTests.swift)\n\n### 1. Basic Chemical Formula Tests\n```swift\nfunc testChemicalFormulas() throws {\n    // Test \\ce{} with simple formula\n    var error: NSError? = nil\n    var list = MTMathListBuilder.build(fromString: \"\\\\ce{H2O}\", error: &error)\n    XCTAssertNil(error)\n    XCTAssertNotNil(list)\n    // Verify H has subscript 2, followed by O\n    \n    // Test calcium ion with charge\n    list = MTMathListBuilder.build(fromString: \"\\\\ce{Ca^{2+}}\", error: &error)\n    XCTAssertNil(error)\n    XCTAssertNotNil(list)\n    // Verify Ca has superscript \"2+\"\n    \n    // Test sodium chloride\n    list = MTMathListBuilder.build(fromString: \"\\\\ce{NaCl}\", error: &error)\n    XCTAssertNil(error)\n    XCTAssertNotNil(list)\n}\n\nfunc testChemicalReactionArrows() throws {\n    var error: NSError? = nil\n    \n    // Test right arrow\n    var list = MTMathListBuilder.build(fromString: \"\\\\ce{A -> B}\", error: &error)\n    XCTAssertNil(error)\n    XCTAssertNotNil(list)\n    \n    // Test equilibrium arrow\n    list = MTMathListBuilder.build(fromString: \"\\\\ce{A <=> B}\", error: &error)\n    XCTAssertNil(error)\n    XCTAssertNotNil(list)\n    \n    // Test bidirectional arrow\n    list = MTMathListBuilder.build(fromString: \"\\\\ce{A <-> B}\", error: &error)\n    XCTAssertNil(error)\n    XCTAssertNotNil(list)\n}\n\nfunc testComplexChemicalFormulas() throws {\n    var error: NSError? = nil\n    \n    // Test sulfuric acid\n    var list = MTMathListBuilder.build(fromString: \"\\\\ce{H2SO4}\", error: &error)\n    XCTAssertNil(error)\n    XCTAssertNotNil(list)\n    \n    // Test calcium hydroxide\n    list = MTMathListBuilder.build(fromString: \"\\\\ce{Ca(OH)2}\", error: &error)\n    XCTAssertNil(error)\n    XCTAssertNotNil(list)\n    \n    // Test coefficient + formula\n    list = MTMathListBuilder.build(fromString: \"\\\\ce{2H2O}\", error: &error)\n    XCTAssertNil(error)\n    XCTAssertNotNil(list)\n}\n\nfunc testChemicalEquations() throws {\n    var error: NSError? = nil\n    \n    // Test complete reaction\n    let list = MTMathListBuilder.build(fromString: \"\\\\ce{2H2 + O2 -> 2H2O}\", error: &error)\n    XCTAssertNil(error)\n    XCTAssertNotNil(list)\n    \n    // Test reversible reaction\n    let list2 = MTMathListBuilder.build(fromString: \"\\\\ce{N2 + 3H2 <=> 2NH3}\", error: &error)\n    XCTAssertNil(error)\n    XCTAssertNotNil(list2)\n}\n\nfunc testChemicalIonNotation() throws {\n    var error: NSError? = nil\n    \n    // Test simple positive ion\n    var list = MTMathListBuilder.build(fromString: \"\\\\ce{Na+}\", error: &error)\n    XCTAssertNil(error)\n    \n    // Test simple negative ion\n    list = MTMathListBuilder.build(fromString: \"\\\\ce{Cl-}\", error: &error)\n    XCTAssertNil(error)\n    \n    // Test complex ion\n    list = MTMathListBuilder.build(fromString: \"\\\\ce{SO4^{2-}}\", error: &error)\n    XCTAssertNil(error)\n    \n    // Test ammonium ion\n    list = MTMathListBuilder.build(fromString: \"\\\\ce{NH4+}\", error: &error)\n    XCTAssertNil(error)\n}\n\nfunc testChemicalLatexRoundTrip() throws {\n    // Test that \\ce{} formulas can be converted back to string\n    let original = \"\\\\ce{H2O}\"\n    let list = MTMathListBuilder.build(fromString: original)\n    XCTAssertNotNil(list)\n    // Note: Round-trip may not be exact due to \\ce{} being expanded\n}\n\nfunc testChemicalErrorHandling() throws {\n    var error: NSError? = nil\n    \n    // Test missing closing brace\n    let list = MTMathListBuilder.build(fromString: \"\\\\ce{H2O\", error: &error)\n    XCTAssertNotNil(error)\n    XCTAssertNil(list)\n}\n```\n\n### 2. Visual Render Tests (in new ChemicalRenderTests.swift or existing test file)\n```swift\nfunc testChemicalFormulaRendering() throws {\n    // Generate test images for visual verification\n    let formulas = [\n        \"\\\\ce{H2O}\",\n        \"\\\\ce{Ca^{2+}}\",\n        \"\\\\ce{H2SO4}\",\n        \"\\\\ce{Ca(OH)2}\",\n        \"\\\\ce{2H2 + O2 -> 2H2O}\",\n        \"\\\\ce{N2 + 3H2 <=> 2NH3}\",\n        \"\\\\ce{[Cu(NH3)4]^{2+}}\"\n    ]\n    \n    for formula in formulas {\n        let label = MTMathUILabel()\n        label.latex = formula\n        label.fontSize = 20\n        \n        let size = label.intrinsicContentSize\n        XCTAssertGreaterThan(size.width, 0)\n        XCTAssertGreaterThan(size.height, 0)\n        \n        // Generate snapshot for visual review\n    }\n}\n```\n\n### 3. Font Style Verification\n```swift\nfunc testChemicalFontStyle() throws {\n    // Verify elements are rendered in roman (upright) style, not italic\n    let list = MTMathListBuilder.build(fromString: \"\\\\ce{NaCl}\")\n    XCTAssertNotNil(list)\n    \n    // Check that atoms have roman font style\n    if let inner = list?.atoms.first as? MTInner,\n       let innerList = inner.innerList {\n        for atom in innerList.atoms {\n            if atom.type == .ordinary || atom.type == .number {\n                XCTAssertEqual(atom.fontStyle, .roman, \"Chemical elements should be roman style\")\n            }\n        }\n    }\n}\n```\n\n### 4. Integration Tests\n- Verify `\\ce{}` works within larger LaTeX expressions\n- Verify `\\ce{}` can have superscripts/subscripts applied to it as a whole\n- Verify spacing between `\\ce{}` and adjacent atoms is correct\n- Test rendering at different font sizes",
        "status": "pending",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Complete amssymb implementation: geometric symbols, additional arrows, and specialized relations",
        "description": "Extend MTMathAtomFactory.supportedLatexSymbols with remaining amssymb package symbols including geometric shapes (blacktriangle, lozenge, bigstar, boxplus, etc.), additional arrows (twoheadarrow, hookarrow, looparrow, circlearrow, etc.), and specialized relations (lessgtr, gtrless, between, circledast, etc.).",
        "details": "## Implementation Overview\n\nThis task completes the amssymb package implementation by adding remaining missing symbols to `MTMathAtomFactory.supportedLatexSymbols` in `Sources/SwiftMath/MathRender/MTMathAtomFactory.swift`.\n\n## Symbols to Add\n\n### 1. Geometric Symbols (type: .ordinary unless noted)\n\n| Command | Unicode | Hex | Description |\n|---------|---------|-----|-------------|\n| `blacktriangle` | ▲ | U+25B2 | Black up-pointing triangle |\n| `blacktriangledown` | ▼ | U+25BC | Black down-pointing triangle |\n| `blacktriangleleft` | ◀ | U+25C0 | Black left-pointing triangle |\n| `blacktriangleright` | ▶ | U+25B6 | Black right-pointing triangle |\n| `vartriangle` | △ | U+25B3 | Same as triangle, alias |\n| `triangledown` | ▽ | U+25BD | White down-pointing triangle |\n| `blacksquare` | ■ | U+25A0 | Black square |\n| `square` | □ | U+25A1 | White square (override placeholder) |\n| `lozenge` | ◊ | U+25CA | Lozenge/diamond shape |\n| `blacklozenge` | ⧫ | U+29EB | Black lozenge |\n| `bigstar` | ★ | U+2605 | Black star |\n| `bigcirc` | ○ | U+25CB | Large circle |\n\n### 2. Box/Circled Operators (type: .binaryOperator)\n\n| Command | Unicode | Hex | Description |\n|---------|---------|-----|-------------|\n| `boxplus` | ⊞ | U+229E | Squared plus |\n| `boxminus` | ⊟ | U+229F | Squared minus |\n| `boxtimes` | ⊠ | U+22A0 | Squared times |\n| `boxdot` | ⊡ | U+22A1 | Squared dot |\n| `circledast` | ⊛ | U+229B | Circled asterisk |\n| `circledcirc` | ⊚ | U+229A | Circled ring |\n| `circleddash` | ⊝ | U+229D | Circled dash |\n\n### 3. Additional Arrows (type: .relation)\n\n| Command | Unicode | Hex | Description |\n|---------|---------|-----|-------------|\n| `leftleftarrows` | ⇇ | U+21C7 | Leftwards paired arrows |\n| `rightrightarrows` | ⇉ | U+21C9 | Rightwards paired arrows |\n| `upuparrows` | ⇈ | U+21C8 | Upwards paired arrows |\n| `downdownarrows` | ⇊ | U+21CA | Downwards paired arrows |\n| `leftrightarrows` | ⇆ | U+21C6 | Left arrow over right arrow |\n| `rightleftarrows` | ⇄ | U+21C4 | Right arrow over left arrow |\n| `twoheadleftarrow` | ↞ | U+219E | Leftwards two-headed arrow |\n| `twoheadrightarrow` | ↠ | U+21A0 | Rightwards two-headed arrow |\n| `leftarrowtail` | ↢ | U+21A2 | Leftwards arrow with tail |\n| `rightarrowtail` | ↣ | U+21A3 | Rightwards arrow with tail |\n| `Lsh` | ↰ | U+21B0 | Upwards arrow with tip leftwards |\n| `Rsh` | ↱ | U+21B1 | Upwards arrow with tip rightwards |\n| `looparrowleft` | ↫ | U+21AB | Leftwards arrow with loop |\n| `looparrowright` | ↬ | U+21AC | Rightwards arrow with loop |\n| `curvearrowleft` | ↶ | U+21B6 | Anticlockwise top semicircle arrow |\n| `curvearrowright` | ↷ | U+21B7 | Clockwise top semicircle arrow |\n| `circlearrowleft` | ↺ | U+21BA | Anticlockwise open circle arrow |\n| `circlearrowright` | ↻ | U+21BB | Clockwise open circle arrow |\n| `multimap` | ⊸ | U+22B8 | Multimap |\n| `leftrightsquigarrow` | ↭ | U+21AD | Left right wave arrow |\n| `rightsquigarrow` | ⇝ | U+21DD | Rightwards squiggle arrow |\n| `leadsto` | ⤳ | U+2933 | Wave arrow pointing right (alias for rightsquigarrow) |\n\n### 4. Harpoons (type: .relation)\n\n| Command | Unicode | Hex | Description |\n|---------|---------|-----|-------------|\n| `leftharpoonup` | ↼ | U+21BC | Leftwards harpoon with barb upwards |\n| `leftharpoondown` | ↽ | U+21BD | Leftwards harpoon with barb downwards |\n| `rightharpoonup` | ⇀ | U+21C0 | Rightwards harpoon with barb upwards |\n| `rightharpoondown` | ⇁ | U+21C1 | Rightwards harpoon with barb downwards |\n| `upharpoonleft` | ↿ | U+21BF | Upwards harpoon with barb leftwards |\n| `upharpoonright` | ↾ | U+21BE | Upwards harpoon with barb rightwards |\n| `downharpoonleft` | ⇃ | U+21C3 | Downwards harpoon with barb leftwards |\n| `downharpoonright` | ⇂ | U+21C2 | Downwards harpoon with barb rightwards |\n| `rightleftharpoons` | ⇌ | U+21CC | Rightwards harpoon over leftwards harpoon |\n| `leftrightharpoons` | ⇋ | U+21CB | Leftwards harpoon over rightwards harpoon |\n\n### 5. Specialized Relations (type: .relation)\n\n| Command | Unicode | Hex | Description |\n|---------|---------|-----|-------------|\n| `lessgtr` | ≶ | U+2276 | Less-than or greater-than |\n| `gtrless` | ≷ | U+2277 | Greater-than or less-than |\n| `lesseqgtr` | ⋚ | U+22DA | Less-than equal to or greater-than |\n| `gtreqless` | ⋛ | U+22DB | Greater-than equal to or less-than |\n| `lesssim` | ≲ | U+2272 | Less-than or equivalent to |\n| `gtrsim` | ≳ | U+2273 | Greater-than or equivalent to |\n| `lessapprox` | ⪅ | U+2A85 | Less-than or approximate |\n| `gtrapprox` | ⪆ | U+2A86 | Greater-than or approximate |\n| `eqslantless` | ⪕ | U+2A95 | Slanted equal to or less-than |\n| `eqslantgtr` | ⪖ | U+2A96 | Slanted equal to or greater-than |\n| `curlyeqprec` | ⋞ | U+22DE | Equal to or precedes |\n| `curlyeqsucc` | ⋟ | U+22DF | Equal to or succeeds |\n| `preccurlyeq` | ≼ | U+227C | Precedes or equal to |\n| `succcurlyeq` | ≽ | U+227D | Succeeds or equal to |\n| `precsim` | ≾ | U+227E | Precedes or equivalent to |\n| `succsim` | ≿ | U+227F | Succeeds or equivalent to |\n| `between` | ≬ | U+226C | Between |\n| `pitchfork` | ⋔ | U+22D4 | Pitchfork |\n| `backepsilon` | ∍ | U+220D | Small contains as member |\n| `therefore` | ∴ | U+2234 | Therefore |\n| `because` | ∵ | U+2235 | Because |\n| `Subset` | ⋐ | U+22D0 | Double subset |\n| `Supset` | ⋑ | U+22D1 | Double superset |\n| `subseteqq` | ⫅ | U+2AC5 | Subset of above equals sign |\n| `supseteqq` | ⫆ | U+2AC6 | Superset of above equals sign |\n| `Vdash` | ⊩ | U+22A9 | Forces |\n| `Vvdash` | ⊪ | U+22AA | Triple vertical bar right turnstile |\n| `vDash` | ⊨ | U+22A8 | True |\n| `trianglelefteq` | ⊴ | U+22B4 | Normal subgroup of or equal to |\n| `trianglerighteq` | ⊵ | U+22B5 | Contains as normal subgroup or equal to |\n| `smallsmile` | ⌣ | U+2323 | Smile |\n| `smallfrown` | ⌢ | U+2322 | Frown |\n| `bumpeq` | ≏ | U+224F | Difference between |\n| `Bumpeq` | ≎ | U+224E | Geometrically equivalent to |\n| `eqcirc` | ≖ | U+2256 | Ring in equal to |\n| `circeq` | ≗ | U+2257 | Ring equal to |\n| `triangleq` | ≜ | U+225C | Delta equal to |\n| `thicksim` | ∼ | U+223C | Same as sim |\n| `thickapprox` | ≈ | U+2248 | Same as approx |\n| `fallingdotseq` | ≒ | U+2252 | Approximately equal to or image of |\n| `risingdotseq` | ≓ | U+2253 | Image of or approximately equal to |\n| `backsim` | ∽ | U+223D | Reversed tilde |\n| `backsimeq` | ⋍ | U+22CD | Reversed tilde equals |\n| `doteqdot` | ≑ | U+2251 | Geometrically equal to |\n\n### 6. Binary Operators (type: .binaryOperator)\n\n| Command | Unicode | Hex | Description |\n|---------|---------|-----|-------------|\n| `triangleleft` | ◁ | U+25C1 | White left-pointing triangle (binary op) |\n| `triangleright` | ▷ | U+25B7 | White right-pointing triangle (binary op) |\n| `bigtriangleup` | △ | U+25B3 | Big triangle up |\n| `bigtriangledown` | ▽ | U+25BD | Big triangle down |\n| `divideontimes` | ⋇ | U+22C7 | Division times |\n| `ltimes` | ⋉ | U+22C9 | Left normal factor semidirect product |\n| `rtimes` | ⋊ | U+22CA | Right normal factor semidirect product |\n| `leftthreetimes` | ⋋ | U+22CB | Left semidirect product |\n| `rightthreetimes` | ⋌ | U+22CC | Right semidirect product |\n| `curlywedge` | ⋏ | U+22CF | Curly logical and |\n| `curlyvee` | ⋎ | U+22CE | Curly logical or |\n| `barwedge` | ⊼ | U+22BC | Nand |\n| `veebar` | ⊻ | U+22BB | Xor |\n| `doublebarwedge` | ⌆ | U+2306 | Perspective |\n| `intercal` | ⊺ | U+22BA | Intercalate |\n| `Cup` | ⋓ | U+22D3 | Double union |\n| `Cap` | ⋒ | U+22D2 | Double intersection |\n| `dotplus` | ∔ | U+2214 | Dot plus |\n| `centerdot` | ⋅ | U+22C5 | Center dot (same as cdot) |\n| `smallsetminus` | ∖ | U+2216 | Small set minus |\n\n### 7. Miscellaneous Symbols (type: .ordinary)\n\n| Command | Unicode | Hex | Description |\n|---------|---------|-----|-------------|\n| `sphericalangle` | ∢ | U+2222 | Spherical angle |\n| `complement` | ∁ | U+2201 | Complement |\n| `Finv` | Ⅎ | U+2132 | Turned capital F |\n| `Game` | ⅁ | U+2141 | Turned sans-serif capital G |\n| `diagup` | ╱ | U+2571 | Box drawings light diagonal upper right to lower left |\n| `diagdown` | ╲ | U+2572 | Box drawings light diagonal upper left to lower right |\n| `flat` | ♭ | U+266D | Music flat sign |\n| `natural` | ♮ | U+266E | Music natural sign |\n| `sharp` | ♯ | U+266F | Music sharp sign |\n| `clubsuit` | ♣ | U+2663 | Black club suit |\n| `diamondsuit` | ♢ | U+2662 | White diamond suit |\n| `heartsuit` | ♡ | U+2661 | White heart suit |\n| `spadesuit` | ♠ | U+2660 | Black spade suit |\n| `hslash` | ℏ | U+210F | Planck constant over 2π (alias for hbar) |\n| `circledS` | Ⓢ | U+24C8 | Circled Latin capital S |\n| `eth` | ð | U+00F0 | Latin small letter eth |\n| `Bbbk` | 𝕜 | U+1D55C | Mathematical double-struck small k |\n| `backprime` | ‵ | U+2035 | Reversed prime |\n\n## Implementation Approach\n\n1. **Add symbols to supportedLatexSymbols dictionary** in MTMathAtomFactory.swift\n2. **Group by category** using comments (follow existing pattern)\n3. **Use correct MTMathAtomType** for each symbol:\n   - `.relation` for comparison/arrow symbols\n   - `.binaryOperator` for operations between operands\n   - `.ordinary` for standalone symbols\n4. **Add aliases** to the aliases dictionary where appropriate (e.g., `leadsto` → `rightsquigarrow`)\n5. **Verify font support** by checking glyphs exist in bundled fonts\n\n## File Modifications\n\n1. **MTMathAtomFactory.swift** (Sources/SwiftMath/MathRender/):\n   - Add ~100 new entries to `supportedLatexSymbols` dictionary\n   - Add aliases to `aliases` dictionary where needed\n   - Organize symbols by category with clear comments\n\n## Copy-Ready Swift Code Snippet (Partial)\n\n```swift\n// === AMSSYMB GEOMETRIC SYMBOLS ===\n\"blacktriangle\" : MTMathAtom(type: .ordinary, value: \"\\u{25B2}\"),\n\"blacktriangledown\" : MTMathAtom(type: .ordinary, value: \"\\u{25BC}\"),\n\"blacktriangleleft\" : MTMathAtom(type: .ordinary, value: \"\\u{25C0}\"),\n\"blacktriangleright\" : MTMathAtom(type: .ordinary, value: \"\\u{25B6}\"),\n\"triangledown\" : MTMathAtom(type: .ordinary, value: \"\\u{25BD}\"),\n\"blacksquare\" : MTMathAtom(type: .ordinary, value: \"\\u{25A0}\"),\n\"lozenge\" : MTMathAtom(type: .ordinary, value: \"\\u{25CA}\"),\n\"blacklozenge\" : MTMathAtom(type: .ordinary, value: \"\\u{29EB}\"),\n\"bigstar\" : MTMathAtom(type: .ordinary, value: \"\\u{2605}\"),\n\"bigcirc\" : MTMathAtom(type: .ordinary, value: \"\\u{25CB}\"),\n\n// === AMSSYMB BOX/CIRCLED OPERATORS ===\n\"boxplus\" : MTMathAtom(type: .binaryOperator, value: \"\\u{229E}\"),\n\"boxminus\" : MTMathAtom(type: .binaryOperator, value: \"\\u{229F}\"),\n\"boxtimes\" : MTMathAtom(type: .binaryOperator, value: \"\\u{22A0}\"),\n\"boxdot\" : MTMathAtom(type: .binaryOperator, value: \"\\u{22A1}\"),\n\"circledast\" : MTMathAtom(type: .binaryOperator, value: \"\\u{229B}\"),\n\"circledcirc\" : MTMathAtom(type: .binaryOperator, value: \"\\u{229A}\"),\n\"circleddash\" : MTMathAtom(type: .binaryOperator, value: \"\\u{229D}\"),\n```\n\n## Dependencies on Completed Work\n\nThis task should also verify and include symbols from Task 1 that may be missing:\n- `varkappa`, `digamma`, `Digamma` (Greek variants)\n- `leqslant`, `geqslant` (slanted inequalities)\n- `preceq`, `succeq` (precedence relations)\n- `longmapsto`, `hookrightarrow`, `hookleftarrow` (arrows)\n- `diamond`, `bowtie`, `vdash`, `dashv` (operators/relations)\n- `beth`, `gimel`, `daleth` (Hebrew letters)\n- `varnothing`, `Box`, `measuredangle` (miscellaneous)\n\n## Font Compatibility Notes\n\nSome symbols may not render in all bundled fonts. Priority should be given to Latin Modern Math which has the best coverage. After implementation, run visual tests to identify any missing glyphs.",
        "testStrategy": "## Unit Tests (in MTMathListBuilderTests.swift)\n\n### 1. Geometric Symbols Test\n```swift\nfunc testAmssymbGeometricSymbols() throws {\n    var error: NSError? = nil\n    \n    let geometricSymbols = [\n        (\"blacktriangle\", \"\\u{25B2}\", MTMathAtomType.ordinary),\n        (\"blacktriangledown\", \"\\u{25BC}\", MTMathAtomType.ordinary),\n        (\"blacksquare\", \"\\u{25A0}\", MTMathAtomType.ordinary),\n        (\"lozenge\", \"\\u{25CA}\", MTMathAtomType.ordinary),\n        (\"bigstar\", \"\\u{2605}\", MTMathAtomType.ordinary),\n    ]\n    \n    for (command, expectedNucleus, expectedType) in geometricSymbols {\n        let list = MTMathListBuilder.build(fromString: \"\\\\\\(command)\", error: &error)\n        XCTAssertNil(error, \"Error parsing \\\\\\(command)\")\n        XCTAssertNotNil(list)\n        XCTAssertEqual(list!.atoms.count, 1)\n        XCTAssertEqual(list!.atoms[0].type, expectedType, \"Wrong type for \\\\\\(command)\")\n        XCTAssertEqual(list!.atoms[0].nucleus, expectedNucleus, \"Wrong nucleus for \\\\\\(command)\")\n    }\n}\n```\n\n### 2. Box/Circled Operators Test\n```swift\nfunc testAmssymbBoxOperators() throws {\n    var error: NSError? = nil\n    \n    let boxOperators = [\n        (\"boxplus\", \"\\u{229E}\"),\n        (\"boxminus\", \"\\u{229F}\"),\n        (\"boxtimes\", \"\\u{22A0}\"),\n        (\"boxdot\", \"\\u{22A1}\"),\n        (\"circledast\", \"\\u{229B}\"),\n    ]\n    \n    for (command, expectedNucleus) in boxOperators {\n        let list = MTMathListBuilder.build(fromString: \"\\\\\\(command)\", error: &error)\n        XCTAssertNil(error)\n        XCTAssertEqual(list!.atoms[0].type, .binaryOperator)\n        XCTAssertEqual(list!.atoms[0].nucleus, expectedNucleus)\n    }\n}\n```\n\n### 3. Additional Arrows Test\n```swift\nfunc testAmssymbArrows() throws {\n    var error: NSError? = nil\n    \n    let arrows = [\n        (\"leftleftarrows\", \"\\u{21C7}\"),\n        (\"rightrightarrows\", \"\\u{21C9}\"),\n        (\"twoheadrightarrow\", \"\\u{21A0}\"),\n        (\"looparrowright\", \"\\u{21AC}\"),\n        (\"curvearrowleft\", \"\\u{21B6}\"),\n        (\"circlearrowleft\", \"\\u{21BA}\"),\n        (\"multimap\", \"\\u{22B8}\"),\n    ]\n    \n    for (command, expectedNucleus) in arrows {\n        let list = MTMathListBuilder.build(fromString: \"\\\\\\(command)\", error: &error)\n        XCTAssertNil(error, \"Error parsing \\\\\\(command)\")\n        XCTAssertEqual(list!.atoms[0].type, .relation, \"Wrong type for \\\\\\(command)\")\n        XCTAssertEqual(list!.atoms[0].nucleus, expectedNucleus)\n    }\n}\n```\n\n### 4. Harpoons Test\n```swift\nfunc testAmssymbHarpoons() throws {\n    var error: NSError? = nil\n    \n    let harpoons = [\n        (\"leftharpoonup\", \"\\u{21BC}\"),\n        (\"rightharpoondown\", \"\\u{21C1}\"),\n        (\"rightleftharpoons\", \"\\u{21CC}\"),\n        (\"leftrightharpoons\", \"\\u{21CB}\"),\n    ]\n    \n    for (command, expectedNucleus) in harpoons {\n        let list = MTMathListBuilder.build(fromString: \"\\\\\\(command)\", error: &error)\n        XCTAssertNil(error)\n        XCTAssertEqual(list!.atoms[0].type, .relation)\n        XCTAssertEqual(list!.atoms[0].nucleus, expectedNucleus)\n    }\n}\n```\n\n### 5. Specialized Relations Test\n```swift\nfunc testAmssymbSpecializedRelations() throws {\n    var error: NSError? = nil\n    \n    let relations = [\n        (\"lessgtr\", \"\\u{2276}\"),\n        (\"gtrless\", \"\\u{2277}\"),\n        (\"between\", \"\\u{226C}\"),\n        (\"therefore\", \"\\u{2234}\"),\n        (\"because\", \"\\u{2235}\"),\n        (\"Vdash\", \"\\u{22A9}\"),\n        (\"trianglelefteq\", \"\\u{22B4}\"),\n    ]\n    \n    for (command, expectedNucleus) in relations {\n        let list = MTMathListBuilder.build(fromString: \"\\\\\\(command)\", error: &error)\n        XCTAssertNil(error, \"Error parsing \\\\\\(command)\")\n        XCTAssertEqual(list!.atoms[0].type, .relation)\n        XCTAssertEqual(list!.atoms[0].nucleus, expectedNucleus)\n    }\n}\n```\n\n### 6. Miscellaneous Symbols Test\n```swift\nfunc testAmssymbMiscSymbols() throws {\n    var error: NSError? = nil\n    \n    let miscSymbols = [\n        (\"complement\", \"\\u{2201}\"),\n        (\"sphericalangle\", \"\\u{2222}\"),\n        (\"flat\", \"\\u{266D}\"),\n        (\"sharp\", \"\\u{266F}\"),\n        (\"clubsuit\", \"\\u{2663}\"),\n        (\"eth\", \"\\u{00F0}\"),\n    ]\n    \n    for (command, expectedNucleus) in miscSymbols {\n        let list = MTMathListBuilder.build(fromString: \"\\\\\\(command)\", error: &error)\n        XCTAssertNil(error)\n        XCTAssertEqual(list!.atoms[0].type, .ordinary)\n        XCTAssertEqual(list!.atoms[0].nucleus, expectedNucleus)\n    }\n}\n```\n\n### 7. Binary Operators Test\n```swift\nfunc testAmssymbBinaryOperators() throws {\n    var error: NSError? = nil\n    \n    let binaryOps = [\n        (\"ltimes\", \"\\u{22C9}\"),\n        (\"rtimes\", \"\\u{22CA}\"),\n        (\"curlywedge\", \"\\u{22CF}\"),\n        (\"curlyvee\", \"\\u{22CE}\"),\n        (\"barwedge\", \"\\u{22BC}\"),\n        (\"veebar\", \"\\u{22BB}\"),\n        (\"dotplus\", \"\\u{2214}\"),\n    ]\n    \n    for (command, expectedNucleus) in binaryOps {\n        let list = MTMathListBuilder.build(fromString: \"\\\\\\(command)\", error: &error)\n        XCTAssertNil(error)\n        XCTAssertEqual(list!.atoms[0].type, .binaryOperator)\n        XCTAssertEqual(list!.atoms[0].nucleus, expectedNucleus)\n    }\n}\n```\n\n### 8. Visual Render Tests (in MathImageTests.swift or new AmssymbRenderTests.swift)\n```swift\nfunc testAmssymbSymbolRendering() throws {\n    let testCases = [\n        \"\\\\blacktriangle \\\\blacksquare \\\\lozenge \\\\bigstar\",\n        \"\\\\boxplus \\\\boxminus \\\\boxtimes \\\\circledast\",\n        \"\\\\leftleftarrows \\\\rightrightarrows \\\\twoheadrightarrow\",\n        \"\\\\leftharpoonup \\\\rightharpoondown \\\\rightleftharpoons\",\n        \"\\\\lessgtr \\\\gtrless \\\\between \\\\therefore\",\n        \"\\\\complement \\\\sphericalangle \\\\flat \\\\sharp\",\n        \"\\\\ltimes \\\\rtimes \\\\curlywedge \\\\barwedge\"\n    ]\n    \n    for latex in testCases {\n        let image = MTMathImage(latex: latex, fontSize: 20)\n        XCTAssertNotNil(image.image, \"Should render: \\(latex)\")\n        // Save images for visual inspection if needed\n    }\n}\n```\n\n### 9. Expression Integration Tests\n```swift\nfunc testAmssymbInExpressions() throws {\n    var error: NSError? = nil\n    \n    // Test symbols in complete expressions\n    let expressions = [\n        \"a \\\\lessgtr b \\\\gtrless c\",\n        \"A \\\\boxplus B \\\\boxminus C\",\n        \"x \\\\leftleftarrows y \\\\rightrightarrows z\",\n        \"\\\\therefore x = y \\\\because z\",\n        \"p \\\\ltimes q \\\\rtimes r\"\n    ]\n    \n    for expr in expressions {\n        let list = MTMathListBuilder.build(fromString: expr, error: &error)\n        XCTAssertNil(error)\n        XCTAssertNotNil(list)\n        XCTAssertGreaterThan(list!.atoms.count, 1)\n    }\n}\n```\n\n### 10. LaTeX Roundtrip Test\n```swift\nfunc testAmssymbRoundTrip() throws {\n    let symbols = [\"boxplus\", \"lessgtr\", \"leftleftarrows\", \"complement\"]\n    \n    for symbol in symbols {\n        let original = \"\\\\\\(symbol)\"\n        let list = MTMathListBuilder.build(fromString: original)\n        XCTAssertNotNil(list)\n        \n        let reconstructed = MTMathListBuilder.mathListToString(list)\n        let list2 = MTMathListBuilder.build(fromString: reconstructed)\n        \n        XCTAssertEqual(list!.atoms[0].nucleus, list2!.atoms[0].nucleus)\n    }\n}\n```\n\n## Manual Testing Checklist\n\n1. `swift build` - Verify project compiles without errors\n2. `swift test` - Run all tests including new amssymb tests\n3. `swift test --filter testAmssymb` - Run amssymb-specific tests\n4. Visual inspection of rendered symbols in test images\n5. Verify symbols render correctly with multiple fonts (Latin Modern, XITS, etc.)\n6. Check symbol spacing in expressions (binary operators should have proper spacing)\n7. Test subscript/superscript attachment to new symbols",
        "status": "pending",
        "dependencies": [
          1,
          4
        ],
        "priority": "low",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement bropd package: derivative commands for partial/ordinary derivatives",
        "description": "Add \\pd{}{} and \\od{}{} for partial/ordinary derivatives, and \\pdd{}{}{} and \\odd{}{}{} for second derivatives following the bropd LaTeX package conventions.",
        "details": "## Implementation Overview\n\nThis task implements the bropd package's derivative commands following established patterns in `MTMathListBuilder.swift` and `MTMathAtomFactory.swift`.\n\n## Commands to Implement\n\n| Command | Arguments | Output | Description |\n|---------|-----------|--------|-------------|\n| `\\pd{f}{x}` | 2 | ∂f/∂x | Partial derivative |\n| `\\od{f}{x}` | 2 | df/dx | Ordinary derivative |\n| `\\pdd{f}{x}{y}` | 3 | ∂²f/∂x∂y | Mixed second partial derivative |\n| `\\odd{f}{x}{n}` | 3 | dⁿf/dxⁿ | nth ordinary derivative |\n\n## Implementation Approach\n\n### 1. Add Partial Derivative Symbol to supportedLatexSymbols\n\nIn `Sources/SwiftMath/MathRender/MTMathAtomFactory.swift`, add the partial symbol if not present:\n```swift\n\"partial\" : MTMathAtom(type: .ordinary, value: \"\\u{2202}\"),  // ∂\n```\n\n### 2. Implement Command Parsing in atomForCommand()\n\nIn `Sources/SwiftMath/MathRender/MTMathListBuilder.swift`, add command handling in the `atomForCommand(_ command:String)` method around line 748 (following the pattern used for `\\frac` at lines 756-761):\n\n```swift\n} else if command == \"pd\" {\n    // Partial derivative: \\pd{f}{x} -> ∂f/∂x\n    let frac = MTFraction()\n    \n    // Build numerator: ∂ + first argument (f)\n    let numerator = MTMathList()\n    numerator.add(MTMathAtom(type: .ordinary, value: \"\\u{2202}\")) // ∂\n    if let arg1 = self.buildInternal(true) {\n        numerator.append(arg1)\n    }\n    \n    // Build denominator: ∂ + second argument (x)\n    let denominator = MTMathList()\n    denominator.add(MTMathAtom(type: .ordinary, value: \"\\u{2202}\")) // ∂\n    if let arg2 = self.buildInternal(true) {\n        denominator.append(arg2)\n    }\n    \n    frac.numerator = numerator\n    frac.denominator = denominator\n    return frac\n} else if command == \"od\" {\n    // Ordinary derivative: \\od{f}{x} -> df/dx\n    let frac = MTFraction()\n    \n    // Build numerator: d + first argument\n    let numerator = MTMathList()\n    numerator.add(MTMathAtom(type: .ordinary, value: \"d\"))\n    if let arg1 = self.buildInternal(true) {\n        numerator.append(arg1)\n    }\n    \n    // Build denominator: d + second argument\n    let denominator = MTMathList()\n    denominator.add(MTMathAtom(type: .ordinary, value: \"d\"))\n    if let arg2 = self.buildInternal(true) {\n        denominator.append(arg2)\n    }\n    \n    frac.numerator = numerator\n    frac.denominator = denominator\n    return frac\n} else if command == \"pdd\" {\n    // Mixed second partial: \\pdd{f}{x}{y} -> ∂²f/∂x∂y\n    let frac = MTFraction()\n    \n    // Build numerator: ∂² + first argument\n    let numerator = MTMathList()\n    let partialAtom = MTMathAtom(type: .ordinary, value: \"\\u{2202}\")\n    partialAtom.superScript = MTMathList()\n    partialAtom.superScript!.add(MTMathAtom(type: .number, value: \"2\"))\n    numerator.add(partialAtom)\n    if let arg1 = self.buildInternal(true) {\n        numerator.append(arg1)\n    }\n    \n    // Build denominator: ∂ + arg2 + ∂ + arg3\n    let denominator = MTMathList()\n    denominator.add(MTMathAtom(type: .ordinary, value: \"\\u{2202}\"))\n    if let arg2 = self.buildInternal(true) {\n        denominator.append(arg2)\n    }\n    denominator.add(MTMathAtom(type: .ordinary, value: \"\\u{2202}\"))\n    if let arg3 = self.buildInternal(true) {\n        denominator.append(arg3)\n    }\n    \n    frac.numerator = numerator\n    frac.denominator = denominator\n    return frac\n} else if command == \"odd\" {\n    // nth ordinary derivative: \\odd{f}{x}{n} -> dⁿf/dxⁿ\n    let frac = MTFraction()\n    \n    // Read all three arguments first\n    let arg1 = self.buildInternal(true)  // f\n    let arg2 = self.buildInternal(true)  // x\n    let arg3 = self.buildInternal(true)  // n (the order)\n    \n    // Build numerator: d^n + f\n    let numerator = MTMathList()\n    let dAtomNum = MTMathAtom(type: .ordinary, value: \"d\")\n    if let order = arg3 {\n        dAtomNum.superScript = MTMathList(order)\n    }\n    numerator.add(dAtomNum)\n    if let f = arg1 {\n        numerator.append(f)\n    }\n    \n    // Build denominator: d + x^n\n    let denominator = MTMathList()\n    denominator.add(MTMathAtom(type: .ordinary, value: \"d\"))\n    if let x = arg2 {\n        // Add x with superscript n\n        if x.atoms.count > 0 {\n            let lastAtom = x.atoms.last!\n            if let order = arg3 {\n                lastAtom.superScript = MTMathList(order)\n            }\n        }\n        denominator.append(x)\n    }\n    \n    frac.numerator = numerator\n    frac.denominator = denominator\n    return frac\n}\n```\n\n### 3. Add LaTeX Output Support in mathListToString()\n\nThe existing fraction output logic at line 573-598 should handle derivative fractions automatically since they use MTFraction. However, round-trip conversion won't reproduce the original `\\pd{}{}` form - this is acceptable as the rendered output will be mathematically equivalent.\n\n### 4. Considerations\n\n- **Font styling**: The \"d\" and \"∂\" symbols should use roman (upright) font style in derivatives. Consider setting `fontStyle = .roman` on these atoms.\n- **Spacing**: Standard fraction spacing applies. No additional spacing commands needed.\n- **Error handling**: If arguments are missing, the existing buildInternal(true) pattern will handle it gracefully (returns empty/nil).\n- **Upright d convention**: Many mathematicians prefer upright \"d\" in derivatives. The implementation uses roman \"d\" by default.\n\n### 5. File Locations\n\n| File | Purpose |\n|------|---------|\n| `Sources/SwiftMath/MathRender/MTMathListBuilder.swift` | Add command parsing in `atomForCommand()` (~line 756) |\n| `Sources/SwiftMath/MathRender/MTMathAtomFactory.swift` | Verify `partial` symbol exists (~line 143) |\n| `Tests/SwiftMathTests/MTMathListBuilderTests.swift` | Add unit tests |",
        "testStrategy": "## Unit Tests (in MTMathListBuilderTests.swift)\n\n### 1. Basic Partial Derivative Test\n```swift\nfunc testPartialDerivative() throws {\n    var error: NSError? = nil\n    \n    // Test \\pd{f}{x}\n    let list = MTMathListBuilder.build(fromString: \"\\\\pd{f}{x}\", error: &error)\n    XCTAssertNil(error)\n    XCTAssertNotNil(list)\n    XCTAssertEqual(list!.atoms.count, 1)\n    \n    let frac = list!.atoms[0] as? MTFraction\n    XCTAssertNotNil(frac)\n    XCTAssertEqual(frac!.type, .fraction)\n    XCTAssertTrue(frac!.hasRule)\n    \n    // Check numerator contains ∂f\n    let numerator = frac!.numerator!\n    XCTAssertEqual(numerator.atoms.count, 2)\n    XCTAssertEqual(numerator.atoms[0].nucleus, \"\\u{2202}\") // ∂\n    XCTAssertEqual(numerator.atoms[1].nucleus, \"f\")\n    \n    // Check denominator contains ∂x\n    let denominator = frac!.denominator!\n    XCTAssertEqual(denominator.atoms.count, 2)\n    XCTAssertEqual(denominator.atoms[0].nucleus, \"\\u{2202}\") // ∂\n    XCTAssertEqual(denominator.atoms[1].nucleus, \"x\")\n}\n```\n\n### 2. Basic Ordinary Derivative Test\n```swift\nfunc testOrdinaryDerivative() throws {\n    var error: NSError? = nil\n    \n    // Test \\od{y}{t}\n    let list = MTMathListBuilder.build(fromString: \"\\\\od{y}{t}\", error: &error)\n    XCTAssertNil(error)\n    XCTAssertNotNil(list)\n    XCTAssertEqual(list!.atoms.count, 1)\n    \n    let frac = list!.atoms[0] as? MTFraction\n    XCTAssertNotNil(frac)\n    \n    // Check numerator contains dy\n    let numerator = frac!.numerator!\n    XCTAssertEqual(numerator.atoms.count, 2)\n    XCTAssertEqual(numerator.atoms[0].nucleus, \"d\")\n    XCTAssertEqual(numerator.atoms[1].nucleus, \"y\")\n    \n    // Check denominator contains dt\n    let denominator = frac!.denominator!\n    XCTAssertEqual(denominator.atoms.count, 2)\n    XCTAssertEqual(denominator.atoms[0].nucleus, \"d\")\n    XCTAssertEqual(denominator.atoms[1].nucleus, \"t\")\n}\n```\n\n### 3. Mixed Second Partial Derivative Test\n```swift\nfunc testMixedSecondPartial() throws {\n    var error: NSError? = nil\n    \n    // Test \\pdd{f}{x}{y}\n    let list = MTMathListBuilder.build(fromString: \"\\\\pdd{f}{x}{y}\", error: &error)\n    XCTAssertNil(error)\n    XCTAssertNotNil(list)\n    XCTAssertEqual(list!.atoms.count, 1)\n    \n    let frac = list!.atoms[0] as? MTFraction\n    XCTAssertNotNil(frac)\n    \n    // Check numerator: ∂² f (∂ with superscript 2, then f)\n    let numerator = frac!.numerator!\n    XCTAssertGreaterThanOrEqual(numerator.atoms.count, 2)\n    XCTAssertEqual(numerator.atoms[0].nucleus, \"\\u{2202}\")\n    XCTAssertNotNil(numerator.atoms[0].superScript)\n    XCTAssertEqual(numerator.atoms[0].superScript!.atoms[0].nucleus, \"2\")\n    \n    // Check denominator: ∂x∂y\n    let denominator = frac!.denominator!\n    XCTAssertGreaterThanOrEqual(denominator.atoms.count, 4) // ∂, x, ∂, y\n}\n```\n\n### 4. Nth Ordinary Derivative Test\n```swift\nfunc testNthOrdinaryDerivative() throws {\n    var error: NSError? = nil\n    \n    // Test \\odd{f}{x}{n}\n    let list = MTMathListBuilder.build(fromString: \"\\\\odd{f}{x}{n}\", error: &error)\n    XCTAssertNil(error)\n    XCTAssertNotNil(list)\n    XCTAssertEqual(list!.atoms.count, 1)\n    \n    let frac = list!.atoms[0] as? MTFraction\n    XCTAssertNotNil(frac)\n    \n    // Check numerator: d^n f\n    let numerator = frac!.numerator!\n    XCTAssertGreaterThanOrEqual(numerator.atoms.count, 2)\n    XCTAssertEqual(numerator.atoms[0].nucleus, \"d\")\n    XCTAssertNotNil(numerator.atoms[0].superScript)\n    \n    // Check denominator: dx^n\n    let denominator = frac!.denominator!\n    XCTAssertGreaterThanOrEqual(denominator.atoms.count, 2)\n}\n```\n\n### 5. Derivatives in Expressions Test\n```swift\nfunc testDerivativesInExpressions() throws {\n    var error: NSError? = nil\n    \n    // Test derivatives in larger expressions\n    let list = MTMathListBuilder.build(fromString: \"\\\\pd{f}{x} + \\\\od{g}{t} = 0\", error: &error)\n    XCTAssertNil(error)\n    XCTAssertNotNil(list)\n    \n    // Should have: fraction, +, fraction, =, 0\n    XCTAssertEqual(list!.atoms.count, 5)\n    XCTAssertEqual(list!.atoms[0].type, .fraction)\n    XCTAssertEqual(list!.atoms[1].type, .binaryOperator)\n    XCTAssertEqual(list!.atoms[2].type, .fraction)\n    XCTAssertEqual(list!.atoms[3].type, .relation)\n    XCTAssertEqual(list!.atoms[4].type, .number)\n}\n```\n\n### 6. Complex Arguments Test\n```swift\nfunc testDerivativeComplexArguments() throws {\n    var error: NSError? = nil\n    \n    // Test with complex expressions as arguments\n    let list = MTMathListBuilder.build(fromString: \"\\\\pd{x^2 + y^2}{x}\", error: &error)\n    XCTAssertNil(error)\n    XCTAssertNotNil(list)\n    \n    let frac = list!.atoms[0] as? MTFraction\n    XCTAssertNotNil(frac)\n    \n    // Numerator should have ∂ plus multiple atoms for x^2 + y^2\n    XCTAssertGreaterThan(frac!.numerator!.atoms.count, 2)\n}\n```\n\n## Visual Render Tests\n\nCreate visual test cases in a new test class or add to existing render tests:\n\n```swift\nfunc testDerivativeRendering() throws {\n    let testCases = [\n        \"\\\\pd{f}{x}\",\n        \"\\\\od{y}{t}\",\n        \"\\\\pdd{f}{x}{y}\",\n        \"\\\\odd{f}{x}{3}\",\n        \"\\\\pd{\\\\psi}{t} = -\\\\frac{\\\\hbar}{2m}\\\\pd{^2\\\\psi}{x^2}\"\n    ]\n    \n    for latex in testCases {\n        let label = MTMathUILabel()\n        label.latex = latex\n        label.fontSize = 20\n        XCTAssertNotNil(label.mathList, \"Failed to parse: \\(latex)\")\n    }\n}\n```\n\n## Integration Verification\n\n1. Run `swift build` to verify compilation\n2. Run `swift test --filter testPartialDerivative` for unit tests\n3. Run `swift test --filter testOrdinaryDerivative` for unit tests\n4. Run full test suite: `swift test`\n5. Visual inspection of rendered derivatives in test images",
        "status": "pending",
        "dependencies": [
          1
        ],
        "priority": "low",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement package registry system: Modular architecture for selective package loading, behavior morphing, and user extensions",
        "description": "Create a protocol-based package registry system that enables modular LaTeX package loading, symbol/command override capability, user-defined extensions, and optional lazy loading of package definitions.",
        "details": "## Implementation Overview\n\nThis task introduces a modular package architecture to replace SwiftMath's current monolithic symbol dictionary approach. The system enables selective loading of LaTeX packages (physics, mhchem, siunitx, etc.), behavior morphing (e.g., different `\\phi` rendering), and user extensions.\n\n## 1. Package Protocol Definition\n\nCreate `Sources/SwiftMath/MathRender/MTPackage.swift`:\n\n```swift\n/// Protocol that all math packages must conform to\npublic protocol MTPackage {\n    /// Unique identifier for the package (e.g., \"physics\", \"mhchem\")\n    static var identifier: String { get }\n    \n    /// Human-readable name\n    static var name: String { get }\n    \n    /// Package version\n    static var version: String { get }\n    \n    /// Dependencies on other packages (by identifier)\n    static var dependencies: [String] { get }\n    \n    /// Priority for symbol resolution (higher = override earlier)\n    static var priority: Int { get }\n    \n    /// Symbols to register (command name -> atom)\n    static var symbols: [String: MTMathAtom] { get }\n    \n    /// Aliases to register (alias -> canonical name)\n    static var aliases: [String: String] { get }\n    \n    /// Command handlers for complex commands that need custom parsing\n    static var commandHandlers: [String: MTCommandHandler] { get }\n    \n    /// Accents to register\n    static var accents: [String: String] { get }\n    \n    /// Delimiters to register\n    static var delimiters: [String: String] { get }\n    \n    /// Optional: Called when package is loaded\n    static func onLoad()\n    \n    /// Optional: Called when package is unloaded\n    static func onUnload()\n}\n\n/// Default implementations for optional members\npublic extension MTPackage {\n    static var dependencies: [String] { [] }\n    static var priority: Int { 0 }\n    static var aliases: [String: String] { [:] }\n    static var commandHandlers: [String: MTCommandHandler] { [:] }\n    static var accents: [String: String] { [:] }\n    static var delimiters: [String: String] { [:] }\n    static func onLoad() {}\n    static func onUnload() {}\n}\n\n/// Handler for complex commands that need custom parsing\npublic typealias MTCommandHandler = (inout MTMathListBuilder) -> MTMathAtom?\n```\n\n## 2. Package Registry Manager\n\nCreate `Sources/SwiftMath/MathRender/MTPackageRegistry.swift`:\n\n```swift\n/// Thread-safe package registry for loading and managing math packages\npublic class MTPackageRegistry {\n    /// Shared singleton instance\n    public static let shared = MTPackageRegistry()\n    \n    private let lock = NSLock()\n    \n    /// Currently loaded packages by identifier\n    private var loadedPackages: [String: MTPackage.Type] = [:]\n    \n    /// Symbol registry (command -> (atom, source package))\n    private var symbolRegistry: [String: (atom: MTMathAtom, package: String)] = [:]\n    \n    /// Alias registry (alias -> (canonical, source package))\n    private var aliasRegistry: [String: (canonical: String, package: String)] = [:]\n    \n    /// Command handler registry (command -> (handler, source package))\n    private var commandHandlerRegistry: [String: (handler: MTCommandHandler, package: String)] = [:]\n    \n    /// Accent registry (accent name -> (unicode, source package))\n    private var accentRegistry: [String: (unicode: String, package: String)] = [:]\n    \n    /// Delimiter registry (delimiter name -> (unicode, source package))\n    private var delimiterRegistry: [String: (unicode: String, package: String)] = [:]\n    \n    /// Load order for dependency resolution\n    private var loadOrder: [String] = []\n    \n    private init() {\n        // Load core package by default\n        loadPackage(CorePackage.self)\n    }\n    \n    /// Load a package and its dependencies\n    public func loadPackage(_ package: MTPackage.Type) throws {\n        lock.lock()\n        defer { lock.unlock() }\n        \n        let id = package.identifier\n        \n        // Skip if already loaded\n        guard loadedPackages[id] == nil else { return }\n        \n        // Load dependencies first\n        for depId in package.dependencies {\n            guard let dep = findPackage(byIdentifier: depId) else {\n                throw MTPackageError.missingDependency(package: id, dependency: depId)\n            }\n            try loadPackage(dep)\n        }\n        \n        // Register symbols (respecting priority)\n        for (name, atom) in package.symbols {\n            if let existing = symbolRegistry[name] {\n                if package.priority > existingPriority(for: existing.package) {\n                    symbolRegistry[name] = (atom, id)\n                }\n            } else {\n                symbolRegistry[name] = (atom, id)\n            }\n        }\n        \n        // Register other components similarly...\n        for (alias, canonical) in package.aliases {\n            aliasRegistry[alias] = (canonical, id)\n        }\n        \n        for (name, handler) in package.commandHandlers {\n            commandHandlerRegistry[name] = (handler, id)\n        }\n        \n        for (name, unicode) in package.accents {\n            accentRegistry[name] = (unicode, id)\n        }\n        \n        for (name, unicode) in package.delimiters {\n            delimiterRegistry[name] = (unicode, id)\n        }\n        \n        loadedPackages[id] = package\n        loadOrder.append(id)\n        \n        package.onLoad()\n    }\n    \n    /// Unload a package\n    public func unloadPackage(_ identifier: String) {\n        lock.lock()\n        defer { lock.unlock() }\n        \n        guard let package = loadedPackages[identifier] else { return }\n        \n        // Remove all symbols registered by this package\n        symbolRegistry = symbolRegistry.filter { $0.value.package != identifier }\n        aliasRegistry = aliasRegistry.filter { $0.value.package != identifier }\n        commandHandlerRegistry = commandHandlerRegistry.filter { $0.value.package != identifier }\n        accentRegistry = accentRegistry.filter { $0.value.package != identifier }\n        delimiterRegistry = delimiterRegistry.filter { $0.value.package != identifier }\n        \n        loadedPackages.removeValue(forKey: identifier)\n        loadOrder.removeAll { $0 == identifier }\n        \n        package.onUnload()\n    }\n    \n    // Query methods for MTMathAtomFactory and MTMathListBuilder integration\n    public func atom(forSymbol name: String) -> MTMathAtom? {\n        lock.lock()\n        defer { lock.unlock() }\n        return symbolRegistry[name]?.atom.copy()\n    }\n    \n    public func resolveAlias(_ alias: String) -> String? {\n        lock.lock()\n        defer { lock.unlock() }\n        return aliasRegistry[alias]?.canonical\n    }\n    \n    public func commandHandler(for command: String) -> MTCommandHandler? {\n        lock.lock()\n        defer { lock.unlock() }\n        return commandHandlerRegistry[command]?.handler\n    }\n    \n    public func accent(forName name: String) -> String? {\n        lock.lock()\n        defer { lock.unlock() }\n        return accentRegistry[name]?.unicode\n    }\n    \n    public func delimiter(forName name: String) -> String? {\n        lock.lock()\n        defer { lock.unlock() }\n        return delimiterRegistry[name]?.unicode\n    }\n    \n    public func isPackageLoaded(_ identifier: String) -> Bool {\n        lock.lock()\n        defer { lock.unlock() }\n        return loadedPackages[identifier] != nil\n    }\n    \n    public func loadedPackageIdentifiers() -> [String] {\n        lock.lock()\n        defer { lock.unlock() }\n        return loadOrder\n    }\n}\n\npublic enum MTPackageError: Error {\n    case missingDependency(package: String, dependency: String)\n    case packageNotFound(identifier: String)\n    case circularDependency(packages: [String])\n}\n```\n\n## 3. Core Package Implementation\n\nCreate `Sources/SwiftMath/MathRender/Packages/CorePackage.swift`:\n\n```swift\n/// Core LaTeX math symbols - always loaded\npublic struct CorePackage: MTPackage {\n    public static let identifier = \"core\"\n    public static let name = \"Core LaTeX Math\"\n    public static let version = \"1.0.0\"\n    public static let priority = 0\n    \n    public static var symbols: [String: MTMathAtom] {\n        // Migrate existing MTMathAtomFactory.supportedLatexSymbols here\n        // This includes Greek letters, basic operators, relations, etc.\n        [\n            \"alpha\": MTMathAtom(type: .variable, value: \"\\u{03B1}\"),\n            \"beta\": MTMathAtom(type: .variable, value: \"\\u{03B2}\"),\n            // ... all symbols from current supportedLatexSymbols\n        ]\n    }\n    \n    public static var aliases: [String: String] {\n        // Migrate from MTMathAtomFactory.aliases\n        [\n            \"lnot\": \"neg\",\n            \"land\": \"wedge\",\n            // ...\n        ]\n    }\n    \n    public static var accents: [String: String] {\n        // Migrate from MTMathAtomFactory.accents\n        [\n            \"grave\": \"\\u{0300}\",\n            \"acute\": \"\\u{0301}\",\n            // ...\n        ]\n    }\n    \n    public static var delimiters: [String: String] {\n        // Migrate from MTMathAtomFactory.delimiters\n        [\n            \".\": \"\",\n            \"(\": \"(\",\n            // ...\n        ]\n    }\n}\n```\n\n## 4. Example User Package\n\nCreate example for documentation:\n\n```swift\n/// Example: Custom symbols package\npublic struct MyCompanyPackage: MTPackage {\n    public static let identifier = \"mycompany\"\n    public static let name = \"My Company Math Extensions\"\n    public static let version = \"1.0.0\"\n    public static let priority = 100  // High priority to override core\n    \n    public static var symbols: [String: MTMathAtom] {\n        [\n            // Custom company logo symbol\n            \"companylogo\": MTMathAtom(type: .ordinary, value: \"®\"),\n            // Override phi with different rendering\n            \"phi\": MTMathAtom(type: .variable, value: \"\\u{03D5}\"),\n        ]\n    }\n}\n\n// Usage:\n// try MTPackageRegistry.shared.loadPackage(MyCompanyPackage.self)\n```\n\n## 5. Integration with Existing Code\n\n### Modify MTMathAtomFactory.swift:\n\n```swift\npublic static func atom(forLatexSymbol name: String) -> MTMathAtom? {\n    var name = name\n    \n    // Check package registry first\n    if let canonicalName = MTPackageRegistry.shared.resolveAlias(name) {\n        name = canonicalName\n    }\n    \n    // Try package registry\n    if let atom = MTPackageRegistry.shared.atom(forSymbol: name) {\n        return atom\n    }\n    \n    // Fallback to legacy static dictionary (for backward compatibility during migration)\n    if let atom = supportedLatexSymbols[name] {\n        return atom.copy()\n    }\n    \n    return nil\n}\n```\n\n### Modify MTMathListBuilder.swift:\n\n```swift\nmutating func atomForCommand(_ command: String) -> MTMathAtom? {\n    // Check for custom command handlers from packages\n    if let handler = MTPackageRegistry.shared.commandHandler(for: command) {\n        return handler(&self)\n    }\n    \n    // Continue with existing logic...\n    if let atom = MTMathAtomFactory.atom(forLatexSymbol: command) {\n        return atom\n    }\n    // ...\n}\n```\n\n## 6. Configuration API\n\nAdd convenience configuration:\n\n```swift\n/// SwiftMath configuration for package loading\npublic struct SwiftMathConfiguration {\n    /// Default configuration with core only\n    public static let minimal = SwiftMathConfiguration(packages: [])\n    \n    /// Configuration with standard packages\n    public static let standard = SwiftMathConfiguration(packages: [\n        AmsMathPackage.self,\n        AmsSymbPackage.self\n    ])\n    \n    /// Custom configuration\n    public init(packages: [MTPackage.Type]) {\n        for package in packages {\n            try? MTPackageRegistry.shared.loadPackage(package)\n        }\n    }\n}\n```\n\n## File Structure\n\n```\nSources/SwiftMath/MathRender/\n├── MTPackage.swift              # Protocol definition\n├── MTPackageRegistry.swift      # Registry manager\n└── Packages/\n    ├── CorePackage.swift        # Core symbols (migrated from MTMathAtomFactory)\n    ├── AmsMathPackage.swift     # amsmath package (future)\n    ├── AmsSymbPackage.swift     # amssymb package (future)\n    ├── PhysicsPackage.swift     # physics package (Task 1)\n    ├── MhchemPackage.swift      # mhchem package (Task 2)\n    └── BropdPackage.swift       # bropd package (Task 4)\n```\n\n## Thread Safety Considerations\n\n- Use `NSLock` for all registry operations (matching existing patterns in codebase)\n- Symbol lookups should be copy-on-return to prevent mutation issues\n- Package loading/unloading should be atomic operations\n\n## Backward Compatibility\n\n- Keep existing `MTMathAtomFactory.supportedLatexSymbols` as fallback\n- Package registry queries first, then falls back to static dictionaries\n- Existing `MTMathAtomFactory.add(latexSymbol:value:)` continues to work",
        "testStrategy": "## Unit Tests (in MTPackageRegistryTests.swift)\n\n### 1. Package Protocol Conformance Test\n```swift\nfunc testPackageProtocolConformance() throws {\n    // Test that CorePackage conforms to MTPackage\n    XCTAssertEqual(CorePackage.identifier, \"core\")\n    XCTAssertEqual(CorePackage.name, \"Core LaTeX Math\")\n    XCTAssertFalse(CorePackage.symbols.isEmpty)\n    XCTAssertEqual(CorePackage.dependencies.count, 0)\n}\n```\n\n### 2. Package Loading Test\n```swift\nfunc testPackageLoading() throws {\n    let registry = MTPackageRegistry.shared\n    \n    // Core should be loaded by default\n    XCTAssertTrue(registry.isPackageLoaded(\"core\"))\n    \n    // Test loading custom package\n    struct TestPackage: MTPackage {\n        static var identifier = \"test\"\n        static var name = \"Test Package\"\n        static var version = \"1.0.0\"\n        static var symbols: [String: MTMathAtom] {\n            [\"testsym\": MTMathAtom(type: .ordinary, value: \"T\")]\n        }\n    }\n    \n    try registry.loadPackage(TestPackage.self)\n    XCTAssertTrue(registry.isPackageLoaded(\"test\"))\n    \n    // Verify symbol is available\n    let atom = registry.atom(forSymbol: \"testsym\")\n    XCTAssertNotNil(atom)\n    XCTAssertEqual(atom?.nucleus, \"T\")\n}\n```\n\n### 3. Symbol Override Priority Test\n```swift\nfunc testSymbolOverridePriority() throws {\n    let registry = MTPackageRegistry.shared\n    \n    struct LowPriorityPackage: MTPackage {\n        static var identifier = \"low\"\n        static var name = \"Low Priority\"\n        static var version = \"1.0.0\"\n        static var priority = 10\n        static var symbols: [String: MTMathAtom] {\n            [\"shared\": MTMathAtom(type: .ordinary, value: \"L\")]\n        }\n    }\n    \n    struct HighPriorityPackage: MTPackage {\n        static var identifier = \"high\"\n        static var name = \"High Priority\"\n        static var version = \"1.0.0\"\n        static var priority = 100\n        static var symbols: [String: MTMathAtom] {\n            [\"shared\": MTMathAtom(type: .ordinary, value: \"H\")]\n        }\n    }\n    \n    try registry.loadPackage(LowPriorityPackage.self)\n    try registry.loadPackage(HighPriorityPackage.self)\n    \n    // High priority should win\n    let atom = registry.atom(forSymbol: \"shared\")\n    XCTAssertEqual(atom?.nucleus, \"H\")\n}\n```\n\n### 4. Package Dependency Test\n```swift\nfunc testPackageDependencies() throws {\n    let registry = MTPackageRegistry.shared\n    \n    struct BasePackage: MTPackage {\n        static var identifier = \"base\"\n        static var name = \"Base\"\n        static var version = \"1.0.0\"\n        static var symbols: [String: MTMathAtom] { [:] }\n    }\n    \n    struct DependentPackage: MTPackage {\n        static var identifier = \"dependent\"\n        static var name = \"Dependent\"\n        static var version = \"1.0.0\"\n        static var dependencies = [\"base\"]\n        static var symbols: [String: MTMathAtom] { [:] }\n    }\n    \n    // Loading dependent should auto-load base\n    try registry.loadPackage(DependentPackage.self)\n    \n    XCTAssertTrue(registry.isPackageLoaded(\"base\"))\n    XCTAssertTrue(registry.isPackageLoaded(\"dependent\"))\n}\n```\n\n### 5. Package Unload Test\n```swift\nfunc testPackageUnloading() throws {\n    let registry = MTPackageRegistry.shared\n    \n    struct UnloadTestPackage: MTPackage {\n        static var identifier = \"unload-test\"\n        static var name = \"Unload Test\"\n        static var version = \"1.0.0\"\n        static var symbols: [String: MTMathAtom] {\n            [\"unloadsym\": MTMathAtom(type: .ordinary, value: \"U\")]\n        }\n    }\n    \n    try registry.loadPackage(UnloadTestPackage.self)\n    XCTAssertNotNil(registry.atom(forSymbol: \"unloadsym\"))\n    \n    registry.unloadPackage(\"unload-test\")\n    XCTAssertFalse(registry.isPackageLoaded(\"unload-test\"))\n    XCTAssertNil(registry.atom(forSymbol: \"unloadsym\"))\n}\n```\n\n### 6. Integration Test with MTMathAtomFactory\n```swift\nfunc testIntegrationWithAtomFactory() throws {\n    // Verify registry-based lookups work through existing API\n    let atom = MTMathAtomFactory.atom(forLatexSymbol: \"alpha\")\n    XCTAssertNotNil(atom)\n    XCTAssertEqual(atom?.nucleus, \"\\u{03B1}\")\n}\n```\n\n### 7. Thread Safety Test\n```swift\nfunc testThreadSafety() throws {\n    let registry = MTPackageRegistry.shared\n    let expectation = XCTestExpectation(description: \"Concurrent access\")\n    expectation.expectedFulfillmentCount = 100\n    \n    for i in 0..<100 {\n        DispatchQueue.global().async {\n            // Concurrent reads\n            _ = registry.atom(forSymbol: \"alpha\")\n            _ = registry.isPackageLoaded(\"core\")\n            expectation.fulfill()\n        }\n    }\n    \n    wait(for: [expectation], timeout: 10.0)\n}\n```\n\n### 8. Command Handler Test\n```swift\nfunc testCommandHandler() throws {\n    struct HandlerTestPackage: MTPackage {\n        static var identifier = \"handler-test\"\n        static var name = \"Handler Test\"\n        static var version = \"1.0.0\"\n        static var symbols: [String: MTMathAtom] { [:] }\n        static var commandHandlers: [String: MTCommandHandler] {\n            [\n                \"customcmd\": { builder in\n                    return MTMathAtom(type: .ordinary, value: \"custom\")\n                }\n            ]\n        }\n    }\n    \n    try MTPackageRegistry.shared.loadPackage(HandlerTestPackage.self)\n    \n    var error: NSError? = nil\n    let list = MTMathListBuilder.build(fromString: \"\\\\customcmd\", error: &error)\n    XCTAssertNil(error)\n    XCTAssertNotNil(list)\n    XCTAssertEqual(list?.atoms.first?.nucleus, \"custom\")\n}\n```\n\n### 9. Backward Compatibility Test\n```swift\nfunc testBackwardCompatibility() throws {\n    // Test that existing API still works\n    MTMathAtomFactory.add(latexSymbol: \"mylegacy\", value: MTMathAtom(type: .ordinary, value: \"L\"))\n    \n    let atom = MTMathAtomFactory.atom(forLatexSymbol: \"mylegacy\")\n    XCTAssertNotNil(atom)\n    XCTAssertEqual(atom?.nucleus, \"L\")\n}\n```\n\n### 10. Missing Dependency Error Test\n```swift\nfunc testMissingDependencyError() throws {\n    struct BadDependencyPackage: MTPackage {\n        static var identifier = \"bad-dep\"\n        static var name = \"Bad Dependency\"\n        static var version = \"1.0.0\"\n        static var dependencies = [\"nonexistent-package\"]\n        static var symbols: [String: MTMathAtom] { [:] }\n    }\n    \n    XCTAssertThrowsError(try MTPackageRegistry.shared.loadPackage(BadDependencyPackage.self)) { error in\n        guard case MTPackageError.missingDependency = error else {\n            XCTFail(\"Expected missingDependency error\")\n            return\n        }\n    }\n}\n```\n\n## Visual Render Tests\n\n### 1. Package Symbol Rendering Test\n```swift\nfunc testPackageSymbolRendering() throws {\n    // Load physics package (if available)\n    // try MTPackageRegistry.shared.loadPackage(PhysicsPackage.self)\n    \n    // Test that symbols render correctly\n    let testCases = [\n        (\"\\\\alpha + \\\\beta\", \"core_symbols\"),\n        (\"\\\\sum_{i=1}^{n} x_i\", \"large_operators\"),\n    ]\n    \n    for (latex, name) in testCases {\n        let image = try renderLatex(latex)\n        saveTestImage(image, name: \"package_\\(name)\")\n    }\n}\n```",
        "status": "pending",
        "dependencies": [
          1,
          2,
          3,
          4
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement siunitx package: SI units, number formatting, and angles",
        "description": "Add \\SI{value}{unit}, \\si{unit}, \\num{number}, and \\ang{degrees} commands for rendering SI units, formatted numbers, and angle values following the siunitx LaTeX package conventions.",
        "details": "## Implementation Overview\n\nThis task implements the siunitx package's core commands for rendering SI units, formatted numbers, and angles. The implementation follows established patterns in `MTMathListBuilder.swift` and `MTMathAtomFactory.swift`.\n\n## Commands to Implement\n\n| Command | Arguments | Output | Description |\n|---------|-----------|--------|-------------|\n| `\\SI{value}{unit}` | 2 | 9.81 m/s² | Value with unit (thin space between) |\n| `\\si{unit}` | 1 | m/s² | Unit only (upright text) |\n| `\\num{number}` | 1 | 1,234.56 | Formatted number |\n| `\\ang{degrees}` | 1-3 | 45°30′15″ | Angle in degrees (;minutes;seconds) |\n\n## 1. Unit Symbols in `MTMathAtomFactory.supportedLatexSymbols`\n\nAdd SI unit macros (upright font, type: `.ordinary`):\n\n```swift\n// SI base units\n\"meter\" : MTMathAtom(type: .ordinary, value: \"m\"),\n\"metre\" : MTMathAtom(type: .ordinary, value: \"m\"),\n\"kilogram\" : MTMathAtom(type: .ordinary, value: \"kg\"),\n\"second\" : MTMathAtom(type: .ordinary, value: \"s\"),\n\"ampere\" : MTMathAtom(type: .ordinary, value: \"A\"),\n\"kelvin\" : MTMathAtom(type: .ordinary, value: \"K\"),\n\"mole\" : MTMathAtom(type: .ordinary, value: \"mol\"),\n\"candela\" : MTMathAtom(type: .ordinary, value: \"cd\"),\n\n// Derived units\n\"hertz\" : MTMathAtom(type: .ordinary, value: \"Hz\"),\n\"newton\" : MTMathAtom(type: .ordinary, value: \"N\"),\n\"pascal\" : MTMathAtom(type: .ordinary, value: \"Pa\"),\n\"joule\" : MTMathAtom(type: .ordinary, value: \"J\"),\n\"watt\" : MTMathAtom(type: .ordinary, value: \"W\"),\n\"coulomb\" : MTMathAtom(type: .ordinary, value: \"C\"),\n\"volt\" : MTMathAtom(type: .ordinary, value: \"V\"),\n\"farad\" : MTMathAtom(type: .ordinary, value: \"F\"),\n\"ohm\" : MTMathAtom(type: .ordinary, value: \"Ω\"),\n\"siemens\" : MTMathAtom(type: .ordinary, value: \"S\"),\n\"weber\" : MTMathAtom(type: .ordinary, value: \"Wb\"),\n\"tesla\" : MTMathAtom(type: .ordinary, value: \"T\"),\n\"henry\" : MTMathAtom(type: .ordinary, value: \"H\"),\n\"lumen\" : MTMathAtom(type: .ordinary, value: \"lm\"),\n\"lux\" : MTMathAtom(type: .ordinary, value: \"lx\"),\n\"becquerel\" : MTMathAtom(type: .ordinary, value: \"Bq\"),\n\"gray\" : MTMathAtom(type: .ordinary, value: \"Gy\"),\n\"sievert\" : MTMathAtom(type: .ordinary, value: \"Sv\"),\n\"katal\" : MTMathAtom(type: .ordinary, value: \"kat\"),\n\n// Common prefixes (to be used in combinations)\n\"yocto\" : MTMathAtom(type: .ordinary, value: \"y\"),\n\"zepto\" : MTMathAtom(type: .ordinary, value: \"z\"),\n\"atto\" : MTMathAtom(type: .ordinary, value: \"a\"),\n\"femto\" : MTMathAtom(type: .ordinary, value: \"f\"),\n\"pico\" : MTMathAtom(type: .ordinary, value: \"p\"),\n\"nano\" : MTMathAtom(type: .ordinary, value: \"n\"),\n\"micro\" : MTMathAtom(type: .ordinary, value: \"µ\"),\n\"milli\" : MTMathAtom(type: .ordinary, value: \"m\"),\n\"centi\" : MTMathAtom(type: .ordinary, value: \"c\"),\n\"deci\" : MTMathAtom(type: .ordinary, value: \"d\"),\n\"deca\" : MTMathAtom(type: .ordinary, value: \"da\"),\n\"hecto\" : MTMathAtom(type: .ordinary, value: \"h\"),\n\"kilo\" : MTMathAtom(type: .ordinary, value: \"k\"),\n\"mega\" : MTMathAtom(type: .ordinary, value: \"M\"),\n\"giga\" : MTMathAtom(type: .ordinary, value: \"G\"),\n\"tera\" : MTMathAtom(type: .ordinary, value: \"T\"),\n\"peta\" : MTMathAtom(type: .ordinary, value: \"P\"),\n\"exa\" : MTMathAtom(type: .ordinary, value: \"E\"),\n\"zetta\" : MTMathAtom(type: .ordinary, value: \"Z\"),\n\"yotta\" : MTMathAtom(type: .ordinary, value: \"Y\"),\n\n// Angle symbols (already exists: degree)\n\"arcminute\" : MTMathAtom(type: .ordinary, value: \"′\"),\n\"arcsecond\" : MTMathAtom(type: .ordinary, value: \"″\"),\n```\n\n## 2. Command Parsing in `MTMathListBuilder.atomForCommand()`\n\nAdd handling for siunitx commands in the `atomForCommand` method:\n\n```swift\n} else if command == \"SI\" {\n    // \\SI{value}{unit} - value with unit\n    return self.parseSICommand()\n} else if command == \"si\" {\n    // \\si{unit} - unit only in upright font\n    return self.parseSiUnitCommand()\n} else if command == \"num\" {\n    // \\num{number} - formatted number\n    return self.parseNumCommand()\n} else if command == \"ang\" {\n    // \\ang{degrees;minutes;seconds} - angle notation\n    return self.parseAngCommand()\n}\n```\n\n## 3. Helper Methods in `MTMathListBuilder`\n\n### 3.1 `parseSICommand()` - Value with Unit\n\n```swift\nmutating func parseSICommand() -> MTMathAtom? {\n    // Parse value argument\n    guard let valueList = self.buildInternal(true) else { return nil }\n    \n    // Parse unit argument\n    guard let unitList = self.parseSiUnitContent() else { return nil }\n    \n    // Create result: value + thin space + unit (upright)\n    let result = MTMathList()\n    result.append(valueList)\n    \n    // Add thin space (3mu) between value and unit\n    let space = MTMathSpace(space: 3)\n    result.add(space)\n    \n    // Add unit atoms with roman font style\n    for atom in unitList.atoms {\n        let atomCopy = atom.copy()\n        atomCopy.fontStyle = .roman\n        result.add(atomCopy)\n    }\n    \n    // Wrap in inner atom for grouping\n    let inner = MTInner()\n    inner.innerList = result\n    return inner\n}\n```\n\n### 3.2 `parseSiUnitCommand()` - Unit Only\n\n```swift\nmutating func parseSiUnitCommand() -> MTMathAtom? {\n    guard let unitList = self.parseSiUnitContent() else { return nil }\n    \n    // Set all atoms to roman font\n    for atom in unitList.atoms {\n        atom.fontStyle = .roman\n    }\n    \n    let inner = MTInner()\n    inner.innerList = unitList\n    return inner\n}\n```\n\n### 3.3 `parseSiUnitContent()` - Parse Unit Notation\n\nThis helper parses unit notation with special handling:\n- `.` or `~` → multiplication (thin space)\n- `/` → division (creates fraction or uses solidus)\n- `^` → superscript (for powers like m², s⁻¹)\n- `_` → subscript\n- Unit macros (e.g., `\\meter`, `\\per\\second`)\n\n```swift\nmutating func parseSiUnitContent() -> MTMathList? {\n    if !self.expectCharacter(\"{\") {\n        self.setError(.characterNotFound, message: \"Missing { for unit\")\n        return nil\n    }\n    \n    let result = MTMathList()\n    \n    while self.hasCharacters {\n        let char = self.getNextCharacter()\n        \n        if char == \"}\" {\n            return result\n        } else if char == \".\" || char == \"~\" {\n            // Multiplication: add thin space\n            let space = MTMathSpace(space: 3)\n            result.add(space)\n        } else if char == \"/\" {\n            // Division: add solidus\n            let solidus = MTMathAtom(type: .ordinary, value: \"/\")\n            solidus.fontStyle = .roman\n            result.add(solidus)\n        } else if char == \"^\" {\n            // Superscript on previous atom\n            if let lastAtom = result.atoms.last {\n                lastAtom.superScript = self.buildInternal(true)\n            }\n        } else if char == \"_\" {\n            // Subscript on previous atom\n            if let lastAtom = result.atoms.last {\n                lastAtom.subScript = self.buildInternal(true)\n            }\n        } else if char == \"\\\\\" {\n            // Command (unit macro like \\meter, \\per)\n            let cmd = self.readCommand()\n            if cmd == \"per\" {\n                // \\per adds \"/\"\n                let solidus = MTMathAtom(type: .ordinary, value: \"/\")\n                solidus.fontStyle = .roman\n                result.add(solidus)\n            } else if let atom = MTMathAtomFactory.atom(forLatexSymbol: cmd) {\n                let atomCopy = atom.copy()\n                atomCopy.fontStyle = .roman\n                result.add(atomCopy)\n            } else {\n                // Unknown unit - treat as text\n                for ch in cmd {\n                    let charAtom = MTMathAtom(type: .ordinary, value: String(ch))\n                    charAtom.fontStyle = .roman\n                    result.add(charAtom)\n                }\n            }\n        } else if char.isLetter || char.isNumber {\n            // Plain text character\n            let atom = MTMathAtom(type: .ordinary, value: String(char))\n            atom.fontStyle = .roman\n            result.add(atom)\n        }\n        // Skip whitespace\n    }\n    \n    self.setError(.mismatchBraces, message: \"Missing } for unit\")\n    return nil\n}\n```\n\n### 3.4 `parseNumCommand()` - Number Formatting\n\n```swift\nmutating func parseNumCommand() -> MTMathAtom? {\n    if !self.expectCharacter(\"{\") {\n        self.setError(.characterNotFound, message: \"Missing { for \\\\num\")\n        return nil\n    }\n    \n    let result = MTMathList()\n    var numberStr = \"\"\n    \n    // Read the number content\n    while self.hasCharacters {\n        let char = self.getNextCharacter()\n        \n        if char == \"}\" {\n            break\n        } else if char == \"e\" || char == \"E\" {\n            // Scientific notation: convert to ×10^\n            if !numberStr.isEmpty {\n                self.addFormattedNumber(numberStr, to: result)\n                numberStr = \"\"\n            }\n            \n            // Add × 10\n            let times = MTMathAtom(type: .binaryOperator, value: \"×\")\n            result.add(times)\n            \n            let ten = MTMathAtom(type: .number, value: \"10\")\n            \n            // Read exponent\n            let exponent = self.buildInternal(true)\n            ten.superScript = exponent\n            result.add(ten)\n            \n            // Expect closing brace\n            if !self.expectCharacter(\"}\") {\n                self.setError(.mismatchBraces, message: \"Missing } for \\\\num\")\n                return nil\n            }\n            \n            let inner = MTInner()\n            inner.innerList = result\n            return inner\n        } else {\n            numberStr.append(char)\n        }\n    }\n    \n    // Format the accumulated number\n    if !numberStr.isEmpty {\n        self.addFormattedNumber(numberStr, to: result)\n    }\n    \n    let inner = MTInner()\n    inner.innerList = result\n    return inner\n}\n\nmutating func addFormattedNumber(_ numStr: String, to list: MTMathList) {\n    // Add digit grouping (thousands separators as thin spaces)\n    // For simplicity, render as-is for now; advanced formatting can be added later\n    for char in numStr {\n        if let atom = MTMathAtomFactory.atom(forCharacter: char) {\n            list.add(atom)\n        }\n    }\n}\n```\n\n### 3.5 `parseAngCommand()` - Angle Notation\n\n```swift\nmutating func parseAngCommand() -> MTMathAtom? {\n    if !self.expectCharacter(\"{\") {\n        self.setError(.characterNotFound, message: \"Missing { for \\\\ang\")\n        return nil\n    }\n    \n    let result = MTMathList()\n    var currentPart = \"\"\n    var partIndex = 0  // 0=degrees, 1=minutes, 2=seconds\n    \n    while self.hasCharacters {\n        let char = self.getNextCharacter()\n        \n        if char == \"}\" {\n            // Process final part\n            if !currentPart.isEmpty {\n                self.addAnglePart(currentPart, partIndex: partIndex, to: result)\n            }\n            break\n        } else if char == \";\" {\n            // Separator between degrees;minutes;seconds\n            if !currentPart.isEmpty {\n                self.addAnglePart(currentPart, partIndex: partIndex, to: result)\n                currentPart = \"\"\n            }\n            partIndex += 1\n        } else {\n            currentPart.append(char)\n        }\n    }\n    \n    let inner = MTInner()\n    inner.innerList = result\n    return inner\n}\n\nmutating func addAnglePart(_ value: String, partIndex: Int, to list: MTMathList) {\n    // Add the numeric value\n    for char in value {\n        if let atom = MTMathAtomFactory.atom(forCharacter: char) {\n            list.add(atom)\n        }\n    }\n    \n    // Add appropriate symbol\n    let symbol: String\n    switch partIndex {\n    case 0: symbol = \"°\"      // degree\n    case 1: symbol = \"′\"      // arcminute (prime)\n    case 2: symbol = \"″\"      // arcsecond (double prime)\n    default: return\n    }\n    \n    let symbolAtom = MTMathAtom(type: .ordinary, value: symbol)\n    list.add(symbolAtom)\n}\n```\n\n## 4. LaTeX-to-String Conversion\n\nUpdate `mathListToString()` to handle round-trip conversion:\n\n```swift\n// In the inner atom handling section, detect siunitx patterns\n// This is optional but helps with round-trip fidelity\n```\n\n## 5. Font Style Application\n\nEnsure units render in upright (roman) font by setting `fontStyle = .roman` on unit atoms. The existing font style system in `MTTypesetter` will handle the rendering.\n\n## Implementation Notes\n\n1. **Thread Safety**: Follow existing patterns using `NSLock` if adding to static dictionaries\n2. **Error Handling**: Use `setError()` for parse errors following existing patterns\n3. **Atom Types**: Use `.ordinary` for unit symbols, `.number` for digits, `.binaryOperator` for operators\n4. **Spacing**: Use `MTMathSpace(space: 3)` for thin space (3mu) between value and unit\n5. **Font Styles**: Apply `.roman` to unit atoms for upright rendering",
        "testStrategy": "## Unit Tests (in MTMathListBuilderTests.swift)\n\n### 1. Basic SI Unit Tests\n\n```swift\nfunc testSIValueUnit() throws {\n    var error: NSError? = nil\n    \n    // Test \\SI{9.81}{m/s^2}\n    let list = MTMathListBuilder.build(fromString: \"\\\\SI{9.81}{m/s^2}\", error: &error)\n    XCTAssertNil(error)\n    XCTAssertNotNil(list)\n    \n    // Should produce: inner containing [9, ., 8, 1, space, m, /, s, ^2]\n    XCTAssertEqual(list!.atoms.count, 1)\n    XCTAssertEqual(list!.atoms[0].type, .inner)\n    \n    let inner = list!.atoms[0] as! MTInner\n    XCTAssertNotNil(inner.innerList)\n    // Verify thin space exists between value and unit\n}\n\nfunc testSIWithKilogram() throws {\n    var error: NSError? = nil\n    \n    // Test \\SI{5}{\\kilogram}\n    let list = MTMathListBuilder.build(fromString: \"\\\\SI{5}{\\\\kilogram}\", error: &error)\n    XCTAssertNil(error)\n    XCTAssertNotNil(list)\n}\n\nfunc testSIWithPrefix() throws {\n    var error: NSError? = nil\n    \n    // Test \\SI{100}{\\milli\\meter}\n    let list = MTMathListBuilder.build(fromString: \"\\\\SI{100}{\\\\milli\\\\meter}\", error: &error)\n    XCTAssertNil(error)\n    XCTAssertNotNil(list)\n}\n```\n\n### 2. Unit-Only Tests (\\si)\n\n```swift\nfunc testSiUnitOnly() throws {\n    var error: NSError? = nil\n    \n    // Test \\si{m/s}\n    let list = MTMathListBuilder.build(fromString: \"\\\\si{m/s}\", error: &error)\n    XCTAssertNil(error)\n    XCTAssertNotNil(list)\n    XCTAssertEqual(list!.atoms.count, 1)\n    XCTAssertEqual(list!.atoms[0].type, .inner)\n}\n\nfunc testSiUnitWithPer() throws {\n    var error: NSError? = nil\n    \n    // Test \\si{\\meter\\per\\second}\n    let list = MTMathListBuilder.build(fromString: \"\\\\si{\\\\meter\\\\per\\\\second}\", error: &error)\n    XCTAssertNil(error)\n    XCTAssertNotNil(list)\n}\n\nfunc testSiUnitSquared() throws {\n    var error: NSError? = nil\n    \n    // Test \\si{m^2}\n    let list = MTMathListBuilder.build(fromString: \"\\\\si{m^2}\", error: &error)\n    XCTAssertNil(error)\n    XCTAssertNotNil(list)\n    \n    // Verify the m has a superscript of 2\n    let inner = list!.atoms[0] as! MTInner\n    let mAtom = inner.innerList!.atoms[0]\n    XCTAssertNotNil(mAtom.superScript)\n}\n```\n\n### 3. Number Formatting Tests (\\num)\n\n```swift\nfunc testNumBasic() throws {\n    var error: NSError? = nil\n    \n    // Test \\num{12345}\n    let list = MTMathListBuilder.build(fromString: \"\\\\num{12345}\", error: &error)\n    XCTAssertNil(error)\n    XCTAssertNotNil(list)\n}\n\nfunc testNumDecimal() throws {\n    var error: NSError? = nil\n    \n    // Test \\num{3.14159}\n    let list = MTMathListBuilder.build(fromString: \"\\\\num{3.14159}\", error: &error)\n    XCTAssertNil(error)\n    XCTAssertNotNil(list)\n}\n\nfunc testNumScientific() throws {\n    var error: NSError? = nil\n    \n    // Test \\num{1.23e4} - should render as 1.23 × 10⁴\n    let list = MTMathListBuilder.build(fromString: \"\\\\num{1.23e4}\", error: &error)\n    XCTAssertNil(error)\n    XCTAssertNotNil(list)\n    \n    // Verify × 10^4 structure exists\n    let inner = list!.atoms[0] as! MTInner\n    var foundTimes = false\n    var foundTenWithSuper = false\n    \n    for atom in inner.innerList!.atoms {\n        if atom.nucleus == \"×\" {\n            foundTimes = true\n        }\n        if atom.nucleus == \"10\" && atom.superScript != nil {\n            foundTenWithSuper = true\n        }\n    }\n    \n    XCTAssertTrue(foundTimes, \"Should have × operator\")\n    XCTAssertTrue(foundTenWithSuper, \"Should have 10 with superscript\")\n}\n\nfunc testNumNegativeExponent() throws {\n    var error: NSError? = nil\n    \n    // Test \\num{6.022e-23}\n    let list = MTMathListBuilder.build(fromString: \"\\\\num{6.022e-23}\", error: &error)\n    XCTAssertNil(error)\n    XCTAssertNotNil(list)\n}\n```\n\n### 4. Angle Tests (\\ang)\n\n```swift\nfunc testAngDegreesOnly() throws {\n    var error: NSError? = nil\n    \n    // Test \\ang{45}\n    let list = MTMathListBuilder.build(fromString: \"\\\\ang{45}\", error: &error)\n    XCTAssertNil(error)\n    XCTAssertNotNil(list)\n    \n    // Should produce 45°\n    let inner = list!.atoms[0] as! MTInner\n    let lastAtom = inner.innerList!.atoms.last!\n    XCTAssertEqual(lastAtom.nucleus, \"°\")\n}\n\nfunc testAngDegreesMinutes() throws {\n    var error: NSError? = nil\n    \n    // Test \\ang{45;30}\n    let list = MTMathListBuilder.build(fromString: \"\\\\ang{45;30}\", error: &error)\n    XCTAssertNil(error)\n    XCTAssertNotNil(list)\n    \n    // Should produce 45°30′\n    let inner = list!.atoms[0] as! MTInner\n    var foundDegree = false\n    var foundArcmin = false\n    \n    for atom in inner.innerList!.atoms {\n        if atom.nucleus == \"°\" { foundDegree = true }\n        if atom.nucleus == \"′\" { foundArcmin = true }\n    }\n    \n    XCTAssertTrue(foundDegree)\n    XCTAssertTrue(foundArcmin)\n}\n\nfunc testAngDegreesMinutesSeconds() throws {\n    var error: NSError? = nil\n    \n    // Test \\ang{45;30;15}\n    let list = MTMathListBuilder.build(fromString: \"\\\\ang{45;30;15}\", error: &error)\n    XCTAssertNil(error)\n    XCTAssertNotNil(list)\n    \n    // Should produce 45°30′15″\n    let inner = list!.atoms[0] as! MTInner\n    var foundDegree = false\n    var foundArcmin = false\n    var foundArcsec = false\n    \n    for atom in inner.innerList!.atoms {\n        if atom.nucleus == \"°\" { foundDegree = true }\n        if atom.nucleus == \"′\" { foundArcmin = true }\n        if atom.nucleus == \"″\" { foundArcsec = true }\n    }\n    \n    XCTAssertTrue(foundDegree)\n    XCTAssertTrue(foundArcmin)\n    XCTAssertTrue(foundArcsec)\n}\n\nfunc testAngDecimalDegrees() throws {\n    var error: NSError? = nil\n    \n    // Test \\ang{45.5}\n    let list = MTMathListBuilder.build(fromString: \"\\\\ang{45.5}\", error: &error)\n    XCTAssertNil(error)\n    XCTAssertNotNil(list)\n}\n```\n\n### 5. Error Handling Tests\n\n```swift\nfunc testSIMissingValue() throws {\n    var error: NSError? = nil\n    \n    // Test \\SI{}{m} - empty value\n    let list = MTMathListBuilder.build(fromString: \"\\\\SI{}{m}\", error: &error)\n    // Should still parse (empty value is valid)\n    XCTAssertNil(error)\n}\n\nfunc testSIMissingUnit() throws {\n    var error: NSError? = nil\n    \n    // Test \\SI{5} - missing unit\n    let _ = MTMathListBuilder.build(fromString: \"\\\\SI{5}\", error: &error)\n    XCTAssertNotNil(error)\n}\n\nfunc testNumMissingBrace() throws {\n    var error: NSError? = nil\n    \n    // Test \\num{123 - missing closing brace\n    let _ = MTMathListBuilder.build(fromString: \"\\\\num{123\", error: &error)\n    XCTAssertNotNil(error)\n}\n\nfunc testAngMissingBrace() throws {\n    var error: NSError? = nil\n    \n    // Test \\ang{45 - missing closing brace\n    let _ = MTMathListBuilder.build(fromString: \"\\\\ang{45\", error: &error)\n    XCTAssertNotNil(error)\n}\n```\n\n### 6. Font Style Tests\n\n```swift\nfunc testSiUnitUprightFont() throws {\n    var error: NSError? = nil\n    \n    // Test that units are rendered in roman (upright) font\n    let list = MTMathListBuilder.build(fromString: \"\\\\si{m}\", error: &error)\n    XCTAssertNil(error)\n    \n    let inner = list!.atoms[0] as! MTInner\n    for atom in inner.innerList!.atoms {\n        XCTAssertEqual(atom.fontStyle, .roman, \"Unit atoms should have roman font style\")\n    }\n}\n```\n\n### 7. Integration Tests\n\n```swift\nfunc testSIInExpression() throws {\n    var error: NSError? = nil\n    \n    // Test siunitx in a larger expression\n    let list = MTMathListBuilder.build(fromString: \"F = ma = \\\\SI{10}{\\\\newton}\", error: &error)\n    XCTAssertNil(error)\n    XCTAssertNotNil(list)\n}\n\nfunc testMultipleSIUnits() throws {\n    var error: NSError? = nil\n    \n    // Test multiple SI units in one expression\n    let list = MTMathListBuilder.build(fromString: \"\\\\SI{5}{m} + \\\\SI{3}{m} = \\\\SI{8}{m}\", error: &error)\n    XCTAssertNil(error)\n    XCTAssertNotNil(list)\n}\n```\n\n## Visual/Render Tests\n\nCreate visual render tests to verify correct appearance:\n\n1. `testSIRenderBasic`: Render `\\SI{9.81}{m/s^2}` and verify value-unit spacing\n2. `testSiUnitRender`: Render `\\si{\\kilo\\meter}` and verify upright font\n3. `testNumScientificRender`: Render `\\num{6.022e23}` and verify ×10^n format\n4. `testAngRender`: Render `\\ang{45;30;15}` and verify degree/minute/second symbols\n\n## Build and Test Commands\n\n```bash\n# Run all tests\nswift test\n\n# Run specific test class\nswift test --filter MTMathListBuilderTests\n\n# Run siunitx-specific tests\nswift test --filter MTMathListBuilderTests.testSI\nswift test --filter MTMathListBuilderTests.testNum\nswift test --filter MTMathListBuilderTests.testAng\n```",
        "status": "pending",
        "dependencies": [
          1,
          5
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement TikZ drawing engine: Core path/node drawing for diagrams using CoreGraphics",
        "description": "Add a TikZ-like drawing engine that parses \\begin{tikzpicture}...\\end{tikzpicture} environments and renders vector graphics (paths, nodes, shapes, arrows) using CoreGraphics, integrating with the existing MTDisplay rendering pipeline.",
        "details": "## Implementation Overview\n\nThis task introduces a major architectural addition to SwiftMath: a TikZ-compatible drawing engine that renders vector graphics diagrams using CoreGraphics. The implementation follows established patterns in the codebase while introducing new subsystems for path parsing and graphics rendering.\n\n## 1. Architecture Design\n\n### New File Structure\nCreate the following files in `Sources/SwiftMath/MathRender/`:\n\n```\nTikZ/\n├── MTTikZParser.swift          # Parses TikZ syntax into drawing commands\n├── MTTikZDisplay.swift         # MTDisplay subclass for rendering TikZ graphics\n├── MTTikZPath.swift            # Path data structures and operations\n├── MTTikZNode.swift            # Node representation and styling\n├── MTTikZCoordinate.swift      # Coordinate system handling\n├── MTTikZStyle.swift           # Style options (colors, line widths, etc.)\n└── MTTikZAtom.swift            # MTMathAtom subclass for TikZ environments\n```\n\n### New Atom Type\nAdd to `MTMathAtomType` enum in `MTMathList.swift`:\n```swift\n/// A TikZ drawing environment\ncase tikzPicture = 1002\n```\n\n### MTTikZAtom Class\n```swift\npublic class MTTikZAtom: MTMathAtom {\n    /// The parsed TikZ commands\n    var commands: [MTTikZCommand] = []\n    /// Drawing options (scale, rotation, etc.)\n    var options: MTTikZOptions?\n    /// Coordinate bounds\n    var bounds: CGRect = .zero\n    \n    init() {\n        super.init()\n        self.type = .tikzPicture\n    }\n}\n```\n\n## 2. TikZ Command Parsing\n\n### Supported Commands (Phase 1 - Core)\n| Command | Syntax | Description |\n|---------|--------|-------------|\n| `\\draw` | `\\draw [options] path;` | Draw paths/shapes |\n| `\\fill` | `\\fill [options] path;` | Fill closed paths |\n| `\\filldraw` | `\\filldraw [options] path;` | Fill and stroke |\n| `\\node` | `\\node [options] at (x,y) {text};` | Place labeled nodes |\n| `\\coordinate` | `\\coordinate (name) at (x,y);` | Define named coordinates |\n| `\\path` | `\\path [options] path;` | Define path without drawing |\n\n### Path Syntax Support\n```swift\nenum MTTikZPathElement {\n    case moveTo(CGPoint)\n    case lineTo(CGPoint)\n    case curveTo(control1: CGPoint, control2: CGPoint, end: CGPoint)\n    case arc(center: CGPoint, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat)\n    case rectangle(CGRect)\n    case circle(center: CGPoint, radius: CGFloat)\n    case ellipse(center: CGPoint, xRadius: CGFloat, yRadius: CGFloat)\n    case closePath\n}\n```\n\n### Coordinate Formats\n```swift\nenum MTTikZCoordinate {\n    case cartesian(x: CGFloat, y: CGFloat)    // (x,y)\n    case polar(angle: CGFloat, radius: CGFloat) // (angle:radius)\n    case named(String)                         // (nodename)\n    case relative(dx: CGFloat, dy: CGFloat)    // ++(dx,dy) or +(dx,dy)\n}\n```\n\n## 3. MTTikZDisplay Implementation\n\nSubclass of `MTDisplay` that renders TikZ graphics:\n\n```swift\nclass MTTikZDisplay: MTDisplay {\n    var commands: [MTTikZCommand] = []\n    var scale: CGFloat = 1.0\n    var coordinateSystem: MTTikZCoordinateSystem\n    \n    override func draw(_ context: CGContext) {\n        super.draw(context)\n        context.saveGState()\n        \n        // Apply coordinate transformation (TikZ uses Y-up, CoreGraphics uses Y-down on iOS)\n        context.translateBy(x: position.x, y: position.y)\n        context.scaleBy(x: scale, y: -scale)  // Flip Y axis\n        \n        for command in commands {\n            renderCommand(command, in: context)\n        }\n        \n        context.restoreGState()\n    }\n    \n    private func renderCommand(_ command: MTTikZCommand, in context: CGContext) {\n        switch command {\n        case .draw(let path, let options):\n            renderPath(path, options: options, stroke: true, fill: false, in: context)\n        case .fill(let path, let options):\n            renderPath(path, options: options, stroke: false, fill: true, in: context)\n        case .filldraw(let path, let options):\n            renderPath(path, options: options, stroke: true, fill: true, in: context)\n        case .node(let node):\n            renderNode(node, in: context)\n        }\n    }\n}\n```\n\n## 4. Style System\n\n### MTTikZStyle Structure\n```swift\nstruct MTTikZStyle {\n    // Stroke properties\n    var strokeColor: MTColor = .black\n    var lineWidth: CGFloat = 0.4  // pt (TikZ default)\n    var lineCap: CGLineCap = .butt\n    var lineJoin: CGLineJoin = .miter\n    var dashPattern: [CGFloat]? = nil\n    \n    // Fill properties\n    var fillColor: MTColor? = nil\n    var fillOpacity: CGFloat = 1.0\n    \n    // Arrow properties\n    var startArrow: MTTikZArrowStyle? = nil\n    var endArrow: MTTikZArrowStyle? = nil\n    \n    // Text properties (for nodes)\n    var font: MTFont? = nil\n    var textColor: MTColor = .black\n    var anchor: MTTikZAnchor = .center\n}\n```\n\n### Predefined Styles\n```swift\nstatic let tikzStyles: [String: MTTikZStyle] = [\n    \"thick\": MTTikZStyle(lineWidth: 0.8),\n    \"very thick\": MTTikZStyle(lineWidth: 1.2),\n    \"thin\": MTTikZStyle(lineWidth: 0.2),\n    \"dashed\": MTTikZStyle(dashPattern: [3, 3]),\n    \"dotted\": MTTikZStyle(dashPattern: [1, 2]),\n    \"->\": MTTikZStyle(endArrow: .stealth),\n    \"<-\": MTTikZStyle(startArrow: .stealth),\n    \"<->\": MTTikZStyle(startArrow: .stealth, endArrow: .stealth),\n]\n```\n\n## 5. Integration with MTMathListBuilder\n\nAdd TikZ environment parsing in `MTMathListBuilder.swift`:\n\n```swift\n// In buildInternal() method, add case for tikzpicture environment\ncase \"tikzpicture\":\n    let tikzAtom = MTTikZAtom()\n    tikzAtom.options = parseTikZOptions()\n    tikzAtom.commands = parseTikZCommands()\n    list.add(tikzAtom)\n```\n\n### Parser Implementation\n```swift\nprivate func parseTikZCommands() -> [MTTikZCommand] {\n    var commands: [MTTikZCommand] = []\n    \n    while !hasCharacters() {\n        skipSpaces()\n        if expectEnvironmentEnd(\"tikzpicture\") { break }\n        \n        if let command = parseTikZCommand() {\n            commands.append(command)\n        }\n    }\n    \n    return commands\n}\n\nprivate func parseTikZCommand() -> MTTikZCommand? {\n    let cmd = readCommand()\n    switch cmd {\n    case \"draw\": return parseDrawCommand()\n    case \"fill\": return parseFillCommand()\n    case \"filldraw\": return parseFilldrawCommand()\n    case \"node\": return parseNodeCommand()\n    case \"coordinate\": return parseCoordinateCommand()\n    case \"path\": return parsePathCommand()\n    default: return nil\n    }\n}\n```\n\n## 6. Integration with MTTypesetter\n\nAdd TikZ handling in `MTTypesetter.swift`:\n\n```swift\ncase .tikzPicture:\n    if let tikzAtom = atom as? MTTikZAtom {\n        let tikzDisplay = createTikZDisplay(tikzAtom, font: font, style: style)\n        currentLine.append(tikzDisplay)\n    }\n\nprivate func createTikZDisplay(_ atom: MTTikZAtom, font: MTFont, style: MTLineStyle) -> MTTikZDisplay {\n    let display = MTTikZDisplay()\n    display.commands = atom.commands\n    display.scale = font.fontSize / 10.0  // Scale based on font size\n    // Calculate bounds from commands\n    display.ascent = calculateTikZAscent(atom)\n    display.descent = calculateTikZDescent(atom)\n    display.width = calculateTikZWidth(atom)\n    return display\n}\n```\n\n## 7. Arrow Rendering\n\n### Arrow Types\n```swift\nenum MTTikZArrowStyle {\n    case stealth      // Standard TikZ arrow\n    case latex        // LaTeX-style arrow\n    case to           // Simple triangle\n    case bar          // Perpendicular line\n    case circle       // Circle at endpoint\n}\n```\n\n### Arrow Drawing\n```swift\nfunc drawArrow(style: MTTikZArrowStyle, at point: CGPoint, angle: CGFloat, context: CGContext) {\n    context.saveGState()\n    context.translateBy(x: point.x, y: point.y)\n    context.rotate(by: angle)\n    \n    switch style {\n    case .stealth:\n        let path = CGMutablePath()\n        path.move(to: CGPoint(x: 0, y: 0))\n        path.addLine(to: CGPoint(x: -6, y: 2))\n        path.addLine(to: CGPoint(x: -4, y: 0))\n        path.addLine(to: CGPoint(x: -6, y: -2))\n        path.closeSubpath()\n        context.addPath(path)\n        context.fillPath()\n    // ... other arrow styles\n    }\n    \n    context.restoreGState()\n}\n```\n\n## 8. Node Rendering with Math Content\n\nNodes can contain math content, requiring integration with existing typesetting:\n\n```swift\nfunc renderNode(_ node: MTTikZNode, in context: CGContext) {\n    // Parse node content as math\n    if let mathList = MTMathListBuilder.build(fromString: node.content, error: nil) {\n        let mathDisplay = MTTypesetter.createLineForMathList(mathList, font: font, style: .text)\n        \n        // Position based on anchor\n        let offset = calculateAnchorOffset(mathDisplay, anchor: node.style.anchor)\n        mathDisplay.position = CGPoint(x: node.position.x + offset.x, y: node.position.y + offset.y)\n        mathDisplay.draw(context)\n    }\n    \n    // Draw node shape if specified (circle, rectangle, etc.)\n    if let shape = node.style.shape {\n        drawNodeShape(shape, around: mathDisplay, in: context)\n    }\n}\n```\n\n## 9. Example Usage\n\n```latex\n\\begin{tikzpicture}\n  \\draw[->] (0,0) -- (2,0) node[right] {$x$};\n  \\draw[->] (0,0) -- (0,2) node[above] {$y$};\n  \\draw[thick, blue] (0,0) circle (1);\n  \\fill[red!50] (1,1) rectangle (1.5,1.5);\n  \\node at (0.5, 0.5) {$O$};\n\\end{tikzpicture}\n```\n\n## 10. Phase 2 Features (Future)\n\nReserve these for future implementation:\n- `\\foreach` loops\n- `\\tikzset` for style definitions\n- Complex path operations (intersections, tangents)\n- Decorations (zigzag, waves, etc.)\n- 3D projections\n- External library support (shapes, arrows, calc)\n\n## Dependencies on Existing Code\n\n- `MTBezierPath` for cross-platform path abstraction\n- `MTColor` for cross-platform color handling\n- `MTDisplay` base class for rendering infrastructure\n- `MTMathListBuilder` for environment parsing patterns\n- `MTTypesetter` for display creation patterns\n- `MTFont` for text rendering within nodes\n",
        "testStrategy": "## Unit Tests (in MTTikZTests.swift)\n\n### 1. Parser Tests\n\n```swift\nfunc testTikZEnvironmentParsing() throws {\n    var error: NSError? = nil\n    let list = MTMathListBuilder.build(fromString: \"\\\\begin{tikzpicture}\\\\draw (0,0) -- (1,1);\\\\end{tikzpicture}\", error: &error)\n    XCTAssertNil(error)\n    XCTAssertNotNil(list)\n    XCTAssertEqual(list?.atoms.count, 1)\n    XCTAssertTrue(list?.atoms[0] is MTTikZAtom)\n}\n\nfunc testTikZCoordinateParsing() throws {\n    // Cartesian\n    let cartesian = MTTikZParser.parseCoordinate(\"(2.5, -1.3)\")\n    XCTAssertEqual(cartesian, .cartesian(x: 2.5, y: -1.3))\n    \n    // Polar\n    let polar = MTTikZParser.parseCoordinate(\"(45:2)\")\n    XCTAssertEqual(polar, .polar(angle: 45, radius: 2))\n    \n    // Named\n    let named = MTTikZParser.parseCoordinate(\"(mynode)\")\n    XCTAssertEqual(named, .named(\"mynode\"))\n}\n\nfunc testTikZDrawCommand() throws {\n    var error: NSError? = nil\n    let list = MTMathListBuilder.build(fromString: \"\\\\begin{tikzpicture}\\\\draw[thick, ->] (0,0) -- (1,0) -- (1,1);\\\\end{tikzpicture}\", error: &error)\n    XCTAssertNil(error)\n    \n    let tikzAtom = list?.atoms[0] as? MTTikZAtom\n    XCTAssertNotNil(tikzAtom)\n    XCTAssertEqual(tikzAtom?.commands.count, 1)\n    \n    if case .draw(let path, let options) = tikzAtom?.commands[0] {\n        XCTAssertEqual(path.elements.count, 3)  // moveTo, lineTo, lineTo\n        XCTAssertTrue(options.style.lineWidth > 0.4)  // thick\n        XCTAssertNotNil(options.style.endArrow)  // ->\n    } else {\n        XCTFail(\"Expected draw command\")\n    }\n}\n\nfunc testTikZFillCommand() throws {\n    var error: NSError? = nil\n    let list = MTMathListBuilder.build(fromString: \"\\\\begin{tikzpicture}\\\\fill[red] (0,0) rectangle (1,1);\\\\end{tikzpicture}\", error: &error)\n    XCTAssertNil(error)\n    \n    let tikzAtom = list?.atoms[0] as? MTTikZAtom\n    if case .fill(let path, let options) = tikzAtom?.commands[0] {\n        XCTAssertNotNil(options.style.fillColor)\n    } else {\n        XCTFail(\"Expected fill command\")\n    }\n}\n\nfunc testTikZNodeCommand() throws {\n    var error: NSError? = nil\n    let list = MTMathListBuilder.build(fromString: \"\\\\begin{tikzpicture}\\\\node[above] at (1,1) {$x$};\\\\end{tikzpicture}\", error: &error)\n    XCTAssertNil(error)\n    \n    let tikzAtom = list?.atoms[0] as? MTTikZAtom\n    if case .node(let node) = tikzAtom?.commands[0] {\n        XCTAssertEqual(node.position, CGPoint(x: 1, y: 1))\n        XCTAssertEqual(node.content, \"$x$\")\n        XCTAssertEqual(node.style.anchor, .south)  // above means anchor is south\n    } else {\n        XCTFail(\"Expected node command\")\n    }\n}\n```\n\n### 2. Path Element Tests\n\n```swift\nfunc testTikZLineToPath() throws {\n    let path = MTTikZParser.parsePath(\"(0,0) -- (1,1) -- (2,0)\")\n    XCTAssertEqual(path.elements.count, 3)\n    XCTAssertEqual(path.elements[0], .moveTo(CGPoint(x: 0, y: 0)))\n    XCTAssertEqual(path.elements[1], .lineTo(CGPoint(x: 1, y: 1)))\n    XCTAssertEqual(path.elements[2], .lineTo(CGPoint(x: 2, y: 0)))\n}\n\nfunc testTikZCirclePath() throws {\n    let path = MTTikZParser.parsePath(\"(0,0) circle (1)\")\n    XCTAssertEqual(path.elements.count, 1)\n    if case .circle(let center, let radius) = path.elements[0] {\n        XCTAssertEqual(center, CGPoint.zero)\n        XCTAssertEqual(radius, 1.0)\n    } else {\n        XCTFail(\"Expected circle\")\n    }\n}\n\nfunc testTikZRectanglePath() throws {\n    let path = MTTikZParser.parsePath(\"(0,0) rectangle (2,1)\")\n    XCTAssertEqual(path.elements.count, 1)\n    if case .rectangle(let rect) = path.elements[0] {\n        XCTAssertEqual(rect, CGRect(x: 0, y: 0, width: 2, height: 1))\n    } else {\n        XCTFail(\"Expected rectangle\")\n    }\n}\n\nfunc testTikZArcPath() throws {\n    let path = MTTikZParser.parsePath(\"(1,0) arc (0:90:1)\")\n    XCTAssertEqual(path.elements.count, 1)\n    if case .arc(_, let radius, let startAngle, let endAngle) = path.elements[0] {\n        XCTAssertEqual(radius, 1.0)\n        XCTAssertEqual(startAngle, 0)\n        XCTAssertEqual(endAngle, 90)\n    } else {\n        XCTFail(\"Expected arc\")\n    }\n}\n\nfunc testTikZBezierPath() throws {\n    let path = MTTikZParser.parsePath(\"(0,0) .. controls (0.5,1) and (1.5,1) .. (2,0)\")\n    XCTAssertEqual(path.elements.count, 2)\n    if case .curveTo(let c1, let c2, let end) = path.elements[1] {\n        XCTAssertEqual(c1, CGPoint(x: 0.5, y: 1))\n        XCTAssertEqual(c2, CGPoint(x: 1.5, y: 1))\n        XCTAssertEqual(end, CGPoint(x: 2, y: 0))\n    } else {\n        XCTFail(\"Expected curve\")\n    }\n}\n```\n\n### 3. Style Tests\n\n```swift\nfunc testTikZColorParsing() throws {\n    XCTAssertEqual(MTTikZStyle.parseColor(\"red\"), MTColor.red)\n    XCTAssertEqual(MTTikZStyle.parseColor(\"blue\"), MTColor.blue)\n    XCTAssertNotNil(MTTikZStyle.parseColor(\"red!50\"))  // 50% red\n    XCTAssertNotNil(MTTikZStyle.parseColor(\"red!50!blue\"))  // 50% mix\n}\n\nfunc testTikZLineStyleParsing() throws {\n    let thick = MTTikZStyle.parse([\"thick\"])\n    XCTAssertEqual(thick.lineWidth, 0.8)\n    \n    let dashed = MTTikZStyle.parse([\"dashed\"])\n    XCTAssertNotNil(dashed.dashPattern)\n    \n    let arrow = MTTikZStyle.parse([\"->\"])\n    XCTAssertNotNil(arrow.endArrow)\n    XCTAssertNil(arrow.startArrow)\n}\n\nfunc testTikZCombinedStyles() throws {\n    let style = MTTikZStyle.parse([\"thick\", \"dashed\", \"red\", \"->\"])\n    XCTAssertEqual(style.lineWidth, 0.8)\n    XCTAssertNotNil(style.dashPattern)\n    XCTAssertEqual(style.strokeColor, MTColor.red)\n    XCTAssertNotNil(style.endArrow)\n}\n```\n\n### 4. Display/Rendering Tests\n\n```swift\nfunc testTikZDisplayDimensions() throws {\n    var error: NSError? = nil\n    let list = MTMathListBuilder.build(fromString: \"\\\\begin{tikzpicture}\\\\draw (0,0) -- (3,2);\\\\end{tikzpicture}\", error: &error)\n    \n    let font = MTFontManager.fontManager.defaultFont!\n    let display = MTTypesetter.createLineForMathList(list!, font: font, style: .display)\n    \n    // Dimensions should reflect the 3x2 drawing area\n    XCTAssertGreaterThan(display.width, 0)\n    XCTAssertGreaterThan(display.ascent, 0)\n}\n\nfunc testTikZNodeWithMath() throws {\n    var error: NSError? = nil\n    let list = MTMathListBuilder.build(fromString: \"\\\\begin{tikzpicture}\\\\node at (0,0) {$\\\\alpha$};\\\\end{tikzpicture}\", error: &error)\n    XCTAssertNil(error)\n    \n    let tikzAtom = list?.atoms[0] as? MTTikZAtom\n    if case .node(let node) = tikzAtom?.commands[0] {\n        XCTAssertEqual(node.content, \"$\\\\alpha$\")\n    } else {\n        XCTFail(\"Expected node with math content\")\n    }\n}\n```\n\n### 5. Visual Render Tests (in MTTikZRenderTests.swift)\n\n```swift\nfunc testTikZBasicShapesRendering() throws {\n    let tikzCode = \"\"\"\n    \\\\begin{tikzpicture}\n      \\\\draw (0,0) -- (2,0) -- (1,1.7) -- cycle;\n      \\\\draw (3,0) circle (0.5);\n      \\\\fill[blue!50] (4,0) rectangle (5,1);\n    \\\\end{tikzpicture}\n    \"\"\"\n    \n    let label = MTMathUILabel()\n    label.latex = tikzCode\n    label.font = MTFontManager.fontManager.defaultFont\n    \n    let image = renderToImage(label, size: CGSize(width: 300, height: 100))\n    // Visual verification that triangle, circle, and rectangle render correctly\n    saveTestImage(image, name: \"tikz_basic_shapes\")\n}\n\nfunc testTikZAxesWithLabels() throws {\n    let tikzCode = \"\"\"\n    \\\\begin{tikzpicture}\n      \\\\draw[->] (0,0) -- (3,0) node[right] {$x$};\n      \\\\draw[->] (0,0) -- (0,2) node[above] {$y$};\n      \\\\node at (0,0) [below left] {$O$};\n    \\\\end{tikzpicture}\n    \"\"\"\n    \n    let label = MTMathUILabel()\n    label.latex = tikzCode\n    \n    let image = renderToImage(label, size: CGSize(width: 200, height: 150))\n    saveTestImage(image, name: \"tikz_axes_labels\")\n}\n\nfunc testTikZArrowStyles() throws {\n    let tikzCode = \"\"\"\n    \\\\begin{tikzpicture}\n      \\\\draw[->] (0,0) -- (1,0);\n      \\\\draw[<-] (0,-0.5) -- (1,-0.5);\n      \\\\draw[<->] (0,-1) -- (1,-1);\n    \\\\end{tikzpicture}\n    \"\"\"\n    \n    let label = MTMathUILabel()\n    label.latex = tikzCode\n    \n    let image = renderToImage(label, size: CGSize(width: 100, height: 80))\n    saveTestImage(image, name: \"tikz_arrows\")\n}\n```\n\n### 6. Error Handling Tests\n\n```swift\nfunc testTikZMissingEndEnvironment() throws {\n    var error: NSError? = nil\n    let _ = MTMathListBuilder.build(fromString: \"\\\\begin{tikzpicture}\\\\draw (0,0) -- (1,1);\", error: &error)\n    XCTAssertNotNil(error)\n    XCTAssertTrue(error?.localizedDescription.contains(\"Missing \\\\end\") ?? false)\n}\n\nfunc testTikZInvalidCoordinate() throws {\n    var error: NSError? = nil\n    let _ = MTMathListBuilder.build(fromString: \"\\\\begin{tikzpicture}\\\\draw (invalid) -- (1,1);\\\\end{tikzpicture}\", error: &error)\n    XCTAssertNotNil(error)\n}\n\nfunc testTikZUnsupportedCommand() throws {\n    var error: NSError? = nil\n    let _ = MTMathListBuilder.build(fromString: \"\\\\begin{tikzpicture}\\\\unsupported;\\\\end{tikzpicture}\", error: &error)\n    // Should either skip unknown command or produce warning\n    // Verify graceful handling\n}\n```\n\n### 7. Integration Tests\n\n```swift\nfunc testTikZInMathExpression() throws {\n    // TikZ diagram alongside regular math\n    let latex = \"$f(x) = x^2$ \\\\begin{tikzpicture}\\\\draw[->] (0,0) -- (1,1);\\\\end{tikzpicture}\"\n    \n    var error: NSError? = nil\n    let list = MTMathListBuilder.build(fromString: latex, error: &error)\n    XCTAssertNil(error)\n    XCTAssertGreaterThan(list?.atoms.count ?? 0, 1)\n}\n\nfunc testTikZWithDifferentFonts() throws {\n    let tikzCode = \"\\\\begin{tikzpicture}\\\\node at (0,0) {$x$};\\\\end{tikzpicture}\"\n    \n    for font in MathFont.allCases {\n        let label = MTMathUILabel()\n        label.latex = tikzCode\n        label.font = MTFontManager.fontManager.font(withName: font.rawValue, size: 20)\n        \n        // Should render without crashes\n        let _ = label.sizeThatFits(CGSize(width: 100, height: 100))\n    }\n}\n```\n\n### Test Execution Commands\n\n```bash\n# Run all TikZ tests\nswift test --filter MTTikZTests\n\n# Run specific test class\nswift test --filter MTTikZParserTests\n\n# Run render tests\nswift test --filter MTTikZRenderTests\n```",
        "status": "pending",
        "dependencies": [
          5
        ],
        "priority": "low",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement chemmacros package: Advanced chemistry notation",
        "description": "Add chemmacros package commands for advanced chemistry notation including oxidation states (\\ox{}), standard state symbols (\\stmark), IUPAC naming (\\iupac{}), phase descriptors (\\phase{}), and particle symbols (\\el, \\prt, \\neu) following the chemmacros LaTeX package conventions.",
        "details": "## Implementation Overview\n\nThis task implements the chemmacros package's core commands for advanced chemistry notation, building upon the mhchem foundation (Task 2). The implementation follows established patterns in `MTMathListBuilder.swift` and `MTMathAtomFactory.swift`.\n\n## 1. Commands to Implement\n\n### Oxidation State Commands\n\n| Command | Arguments | Output | Description |\n|---------|-----------|--------|-------------|\n| `\\ox{n,E}` | 2 (comma-separated) | E with n above | Oxidation state notation |\n| `\\ox*{n,E}` | 2 (comma-separated) | E with (n) above | Oxidation state with parentheses |\n| `\\ox{0,Fe}` | example | Fe⁰ | Zero oxidation state |\n| `\\ox{+2,Fe}` | example | Fe^(II) | Positive oxidation with Roman numerals |\n| `\\ox{-1,Cl}` | example | Cl^(-I) | Negative oxidation state |\n\n### Standard State Symbols\n\n| Command | Output | Unicode | Description |\n|---------|--------|---------|-------------|\n| `\\stmark` | ° | U+00B0 | Standard state (Plimsoll) mark |\n| `\\Stmark` | ⦵ | U+29B5 | Alternative standard state symbol |\n| `\\stdmark` | ⊖ | U+2296 | Standard state (circled minus) |\n\n### Phase Descriptors\n\n| Command | Arguments | Output | Description |\n|---------|-----------|--------|-------------|\n| `\\phase{s}` | 1 | (s) | Solid phase |\n| `\\phase{l}` | 1 | (l) | Liquid phase |\n| `\\phase{g}` | 1 | (g) | Gas phase |\n| `\\phase{aq}` | 1 | (aq) | Aqueous phase |\n| `\\sld` | 0 | (s) | Solid shorthand |\n| `\\lqd` | 0 | (l) | Liquid shorthand |\n| `\\gas` | 0 | (g) | Gas shorthand |\n| `\\aq` | 0 | (aq) | Aqueous shorthand |\n\n### Particle Symbols\n\n| Command | Output | Unicode/Rendering | Type |\n|---------|--------|-------------------|------|\n| `\\el` | e⁻ | electron | .ordinary |\n| `\\prt` | p⁺ | proton | .ordinary |\n| `\\neu` | n⁰ | neutron | .ordinary |\n| `\\Nu` | ν | neutrino (U+03BD) | .ordinary |\n| `\\af` | Af | affinity label | .ordinary |\n| `\\pos` | e⁺ | positron | .ordinary |\n\n### IUPAC Naming Commands\n\n| Command | Arguments | Output | Description |\n|---------|-----------|--------|-------------|\n| `\\iupac{name}` | 1 | upright text | IUPAC chemical name |\n| `\\cip{R}` | 1 | (R) italic | CIP stereodescriptor |\n| `\\cis` | 0 | cis- italic | cis prefix |\n| `\\trans` | 0 | trans- italic | trans prefix |\n| `\\Rconf` | 0 | (R) | R configuration |\n| `\\Sconf` | 0 | (S) | S configuration |\n\n### Enthalpy/Thermodynamic Commands\n\n| Command | Output | Description |\n|---------|--------|-------------|\n| `\\enthalpy` | ΔH° | Standard enthalpy change |\n| `\\entropy` | ΔS° | Standard entropy change |\n| `\\gibbs` | ΔG° | Standard Gibbs energy change |\n\n## 2. Implementation in MTMathListBuilder.swift\n\n### Oxidation State Parsing\n\n```swift\n} else if command == \"ox\" {\n    // Parse optional star for parenthesized output\n    let useParens = hasCharacters && string[currentCharIndex] == \"*\"\n    if useParens { _ = getNextCharacter() }\n    \n    // Parse {oxidation,element} format\n    guard let content = readBracedContent() else {\n        setError(.mismatchBraces, message: \"Missing argument for \\\\ox\")\n        return nil\n    }\n    \n    // Split on comma to get oxidation number and element\n    let parts = content.split(separator: \",\", maxSplits: 1)\n    guard parts.count == 2 else {\n        setError(.invalidCommand, message: \"\\\\ox requires format {n,element}\")\n        return nil\n    }\n    \n    let oxidation = String(parts[0]).trimmingCharacters(in: .whitespaces)\n    let element = String(parts[1]).trimmingCharacters(in: .whitespaces)\n    \n    // Build element with oxidation state superscript\n    let result = MTMathList()\n    \n    // Parse element as math\n    var elemBuilder = MTMathListBuilder(string: element)\n    if let elemList = elemBuilder.build() {\n        result.append(elemList)\n    }\n    \n    // Add oxidation state as superscript (convert to Roman numerals if needed)\n    let oxAtom = MTMathAtom(type: .ordinary, value: \"\")\n    let superScript = MTMathList()\n    \n    if useParens {\n        superScript.add(MTMathAtom(type: .open, value: \"(\"))\n    }\n    \n    // Convert numeric oxidation to Roman numeral for positive values\n    let oxValue = formatOxidationState(oxidation)\n    for char in oxValue {\n        superScript.add(MTMathAtom(type: .ordinary, value: String(char)))\n    }\n    \n    if useParens {\n        superScript.add(MTMathAtom(type: .close, value: \")\"))\n    }\n    \n    // Attach as superscript to last atom in result\n    if let lastAtom = result.atoms.last {\n        lastAtom.superScript = superScript\n    }\n    \n    return result.atoms.first\n}\n```\n\n### Phase Descriptor Parsing\n\n```swift\n} else if command == \"phase\" {\n    // Parse braced phase descriptor\n    guard let phase = readBracedContent() else {\n        setError(.mismatchBraces, message: \"Missing argument for \\\\phase\")\n        return nil\n    }\n    \n    // Create parenthesized phase descriptor in subscript position\n    let result = MTMathList()\n    result.add(MTMathAtom(type: .open, value: \"(\"))\n    \n    // Render phase in upright/roman text\n    for char in phase {\n        let atom = MTMathAtom(type: .ordinary, value: String(char))\n        atom.fontStyle = .roman\n        result.add(atom)\n    }\n    \n    result.add(MTMathAtom(type: .close, value: \")\"))\n    \n    // Wrap in inner for proper grouping\n    let inner = MTInner()\n    inner.innerList = result\n    return inner\n}\n```\n\n## 3. Symbols to Add in MTMathAtomFactory.supportedLatexSymbols\n\n```swift\n// Chemmacros standard state symbols\n\"stmark\" : MTMathAtom(type: .ordinary, value: \"\\u{00B0}\"),      // ° degree sign\n\"Stmark\" : MTMathAtom(type: .ordinary, value: \"\\u{29B5}\"),      // ⦵ circle with horizontal bar\n\"stdmark\" : MTMathAtom(type: .ordinary, value: \"\\u{2296}\"),     // ⊖ circled minus\n\n// Chemmacros particle shortcuts\n\"el\" : createParticleAtom(\"e\", \"-\"),      // electron e⁻\n\"prt\" : createParticleAtom(\"p\", \"+\"),     // proton p⁺  \n\"neu\" : createParticleAtom(\"n\", \"0\"),     // neutron n⁰\n\"pos\" : createParticleAtom(\"e\", \"+\"),     // positron e⁺\n\"Nu\" : MTMathAtom(type: .ordinary, value: \"\\u{03BD}\"),          // ν neutrino\n\n// Phase shortcuts (simple text atoms)\n\"sld\" : createPhaseAtom(\"s\"),             // (s)\n\"lqd\" : createPhaseAtom(\"l\"),             // (l)\n\"gas\" : createPhaseAtom(\"g\"),             // (g)\n\"aq\" : createPhaseAtom(\"aq\"),             // (aq)\n\n// Stereochemistry prefixes\n\"cis\" : createItalicTextAtom(\"cis-\"),\n\"trans\" : createItalicTextAtom(\"trans-\"),\n\"Rconf\" : createParenTextAtom(\"R\"),       // (R)\n\"Sconf\" : createParenTextAtom(\"S\"),       // (S)\n```\n\n## 4. Helper Functions in MTMathAtomFactory\n\n```swift\n/// Creates a particle atom with base and charge superscript\nstatic func createParticleAtom(_ base: String, _ charge: String) -> MTMathAtom {\n    let atom = MTMathAtom(type: .ordinary, value: base)\n    let superScript = MTMathList()\n    superScript.add(MTMathAtom(type: .ordinary, value: charge))\n    atom.superScript = superScript\n    return atom\n}\n\n/// Creates a parenthesized phase descriptor\nstatic func createPhaseAtom(_ phase: String) -> MTInner {\n    let inner = MTInner()\n    let list = MTMathList()\n    list.add(MTMathAtom(type: .open, value: \"(\"))\n    for char in phase {\n        let atom = MTMathAtom(type: .ordinary, value: String(char))\n        atom.fontStyle = .roman\n        list.add(atom)\n    }\n    list.add(MTMathAtom(type: .close, value: \")\"))\n    inner.innerList = list\n    return inner\n}\n\n/// Converts oxidation number to Roman numeral representation\nstatic func formatOxidationState(_ ox: String) -> String {\n    // Handle sign prefix\n    var sign = \"\"\n    var num = ox\n    if ox.hasPrefix(\"+\") || ox.hasPrefix(\"-\") {\n        sign = String(ox.first!)\n        num = String(ox.dropFirst())\n    }\n    \n    guard let value = Int(num) else { return ox }\n    \n    // Convert to Roman numerals for standard representation\n    let romans = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\"]\n    if value >= 0 && value < romans.count {\n        return sign + romans[value]\n    }\n    return ox // Fallback to original\n}\n```\n\n## 5. Integration with Package Registry (Task 5)\n\nWhen the package registry system is implemented, chemmacros should be registered as:\n\n```swift\nstruct ChemmacrosPackage: MTPackage {\n    static let identifier = \"chemmacros\"\n    static let name = \"Chemmacros\"\n    static let version = \"1.0\"\n    static let dependencies: [String] = [\"mhchem\"]  // Requires mhchem\n    \n    static let symbols: [String: MTMathAtom] = [\n        // All symbols defined above\n    ]\n    \n    static let commands: [String: CommandHandler] = [\n        \"ox\": OxidationStateHandler(),\n        \"phase\": PhaseDescriptorHandler(),\n        \"iupac\": IUPACHandler(),\n        // etc.\n    ]\n}\n```\n\n## 6. Files to Modify\n\n1. **MTMathListBuilder.swift**: Add command parsing for `\\ox{}`, `\\phase{}`, `\\iupac{}`, `\\cip{}`\n2. **MTMathAtomFactory.swift**: Add symbol entries and helper functions\n3. **MTMathListBuilderTests.swift**: Add comprehensive unit tests\n\n## 7. Compatibility Notes\n\n- This implementation focuses on the most commonly used chemmacros commands\n- Advanced features like orbital diagrams (`\\orbital{}`) require graphics capabilities beyond current scope\n- The `\\ox{}` command uses comma-separated arguments similar to LaTeX's chemmacros behavior\n- Phase descriptors render in upright (roman) font per IUPAC conventions",
        "testStrategy": "## Unit Tests (in MTMathListBuilderTests.swift)\n\n### 1. Oxidation State Tests\n\n```swift\nfunc testOxidationStateBasic() throws {\n    var error: NSError? = nil\n    \n    // Test \\ox{+2,Fe}\n    let list = MTMathListBuilder.build(fromString: \"\\\\ox{+2,Fe}\", error: &error)\n    XCTAssertNil(error)\n    XCTAssertNotNil(list)\n    \n    // Verify Fe has superscript with Roman numeral\n    let atom = list!.atoms.first\n    XCTAssertNotNil(atom?.superScript)\n    // Superscript should contain \"+II\"\n}\n\nfunc testOxidationStateZero() throws {\n    var error: NSError? = nil\n    \n    // Test \\ox{0,Fe}\n    let list = MTMathListBuilder.build(fromString: \"\\\\ox{0,Fe}\", error: &error)\n    XCTAssertNil(error)\n    \n    // Superscript should be \"0\" (not Roman numeral for zero)\n}\n\nfunc testOxidationStateNegative() throws {\n    var error: NSError? = nil\n    \n    // Test \\ox{-1,Cl}\n    let list = MTMathListBuilder.build(fromString: \"\\\\ox{-1,Cl}\", error: &error)\n    XCTAssertNil(error)\n    \n    // Superscript should contain \"-I\"\n}\n\nfunc testOxidationStateWithParens() throws {\n    var error: NSError? = nil\n    \n    // Test \\ox*{+3,Fe}\n    let list = MTMathListBuilder.build(fromString: \"\\\\ox*{+3,Fe}\", error: &error)\n    XCTAssertNil(error)\n    \n    // Superscript should contain \"(+III)\"\n}\n\nfunc testOxidationStateMissingArgument() throws {\n    var error: NSError? = nil\n    \n    // Test error case\n    let list = MTMathListBuilder.build(fromString: \"\\\\ox{Fe}\", error: &error)\n    XCTAssertNotNil(error)\n    XCTAssertTrue(error!.localizedDescription.contains(\"requires format\"))\n}\n```\n\n### 2. Standard State Symbol Tests\n\n```swift\nfunc testStandardStateSymbols() throws {\n    var error: NSError? = nil\n    \n    // Test \\stmark\n    var list = MTMathListBuilder.build(fromString: \"\\\\stmark\", error: &error)\n    XCTAssertNil(error)\n    XCTAssertEqual(list?.atoms.first?.nucleus, \"\\u{00B0}\")\n    \n    // Test \\Stmark\n    list = MTMathListBuilder.build(fromString: \"\\\\Stmark\", error: &error)\n    XCTAssertNil(error)\n    XCTAssertEqual(list?.atoms.first?.nucleus, \"\\u{29B5}\")\n    \n    // Test \\stdmark\n    list = MTMathListBuilder.build(fromString: \"\\\\stdmark\", error: &error)\n    XCTAssertNil(error)\n    XCTAssertEqual(list?.atoms.first?.nucleus, \"\\u{2296}\")\n}\n\nfunc testStandardStateInExpression() throws {\n    var error: NSError? = nil\n    \n    // Test in context: ΔH°\n    let list = MTMathListBuilder.build(fromString: \"\\\\Delta H\\\\stmark\", error: &error)\n    XCTAssertNil(error)\n    XCTAssertEqual(list?.atoms.count, 3) // Delta, H, °\n}\n```\n\n### 3. Phase Descriptor Tests\n\n```swift\nfunc testPhaseDescriptorCommand() throws {\n    var error: NSError? = nil\n    \n    // Test \\phase{s}\n    let list = MTMathListBuilder.build(fromString: \"\\\\phase{s}\", error: &error)\n    XCTAssertNil(error)\n    XCTAssertNotNil(list)\n    \n    // Verify renders as (s) with upright font\n    let inner = list?.atoms.first as? MTInner\n    XCTAssertNotNil(inner)\n}\n\nfunc testPhaseDescriptorAqueous() throws {\n    var error: NSError? = nil\n    \n    // Test \\phase{aq}\n    let list = MTMathListBuilder.build(fromString: \"\\\\phase{aq}\", error: &error)\n    XCTAssertNil(error)\n    \n    // Verify two-character phase\n}\n\nfunc testPhaseShortcuts() throws {\n    var error: NSError? = nil\n    \n    let shortcuts = [\n        (\"\\\\sld\", \"(s)\"),\n        (\"\\\\lqd\", \"(l)\"),\n        (\"\\\\gas\", \"(g)\"),\n        (\"\\\\aq\", \"(aq)\")\n    ]\n    \n    for (command, expected) in shortcuts {\n        let list = MTMathListBuilder.build(fromString: command, error: &error)\n        XCTAssertNil(error, \"Failed for \\(command)\")\n        XCTAssertNotNil(list)\n    }\n}\n\nfunc testPhaseInChemicalEquation() throws {\n    var error: NSError? = nil\n    \n    // Test: NaCl\\phase{s}\n    let list = MTMathListBuilder.build(fromString: \"NaCl\\\\phase{s}\", error: &error)\n    XCTAssertNil(error)\n    // Verify NaCl followed by (s)\n}\n```\n\n### 4. Particle Symbol Tests\n\n```swift\nfunc testParticleSymbols() throws {\n    var error: NSError? = nil\n    \n    let particles = [\n        (\"\\\\el\", \"e\", \"-\"),    // electron\n        (\"\\\\prt\", \"p\", \"+\"),   // proton\n        (\"\\\\neu\", \"n\", \"0\"),   // neutron\n        (\"\\\\pos\", \"e\", \"+\")    // positron\n    ]\n    \n    for (command, base, charge) in particles {\n        let list = MTMathListBuilder.build(fromString: command, error: &error)\n        XCTAssertNil(error, \"Failed for \\(command)\")\n        XCTAssertNotNil(list)\n        \n        let atom = list?.atoms.first\n        XCTAssertEqual(atom?.nucleus, base)\n        XCTAssertNotNil(atom?.superScript)\n        XCTAssertEqual(atom?.superScript?.atoms.first?.nucleus, charge)\n    }\n}\n\nfunc testNeutrinoSymbol() throws {\n    var error: NSError? = nil\n    \n    // Test \\Nu (neutrino)\n    let list = MTMathListBuilder.build(fromString: \"\\\\Nu\", error: &error)\n    XCTAssertNil(error)\n    XCTAssertEqual(list?.atoms.first?.nucleus, \"\\u{03BD}\")\n}\n```\n\n### 5. IUPAC/Stereochemistry Tests\n\n```swift\nfunc testStereochemistryPrefixes() throws {\n    var error: NSError? = nil\n    \n    // Test \\cis\n    var list = MTMathListBuilder.build(fromString: \"\\\\cis\", error: &error)\n    XCTAssertNil(error)\n    // Verify italic rendering\n    \n    // Test \\trans\n    list = MTMathListBuilder.build(fromString: \"\\\\trans\", error: &error)\n    XCTAssertNil(error)\n    \n    // Test \\Rconf\n    list = MTMathListBuilder.build(fromString: \"\\\\Rconf\", error: &error)\n    XCTAssertNil(error)\n    \n    // Test \\Sconf\n    list = MTMathListBuilder.build(fromString: \"\\\\Sconf\", error: &error)\n    XCTAssertNil(error)\n}\n\nfunc testIUPACCommand() throws {\n    var error: NSError? = nil\n    \n    // Test \\iupac{ethanol}\n    let list = MTMathListBuilder.build(fromString: \"\\\\iupac{ethanol}\", error: &error)\n    XCTAssertNil(error)\n    \n    // Verify upright text rendering\n}\n```\n\n### 6. Integration Tests\n\n```swift\nfunc testChemmacrosWithMhchem() throws {\n    var error: NSError? = nil\n    \n    // Test combined usage (requires mhchem Task 2)\n    // Example: Fe\\ox{+3} in chemical context\n    let list = MTMathListBuilder.build(fromString: \"Fe\\\\ox{+3,} + 3e^- \\\\rightarrow Fe\", error: &error)\n    // Note: Full integration test after mhchem is implemented\n}\n\nfunc testThermodynamicExpression() throws {\n    var error: NSError? = nil\n    \n    // Test: ΔH° = -285 kJ/mol\n    let list = MTMathListBuilder.build(fromString: \"\\\\Delta H\\\\stmark = -285\", error: &error)\n    XCTAssertNil(error)\n    XCTAssertEqual(list?.atoms.count, 5) // Delta, H, °, =, -285\n}\n```\n\n### 7. Visual Render Tests (in separate test class)\n\n```swift\nfunc testChemmacrosRendering() throws {\n    let testCases = [\n        (\"ox_iron_plus2\", \"\\\\ox{+2,Fe}\"),\n        (\"ox_chlorine_minus1\", \"\\\\ox{-1,Cl}\"),\n        (\"phase_solid\", \"H_2O\\\\phase{s}\"),\n        (\"phase_aqueous\", \"NaCl\\\\phase{aq}\"),\n        (\"electron\", \"\\\\el\"),\n        (\"proton\", \"\\\\prt\"),\n        (\"standard_state\", \"\\\\Delta G\\\\stmark\"),\n        (\"stereochemistry\", \"\\\\cis-\\\\trans\")\n    ]\n    \n    for (name, latex) in testCases {\n        let label = MTMathUILabel()\n        label.latex = latex\n        label.fontSize = 20\n        \n        // Render and save as test artifact\n        // Verify visual correctness\n    }\n}\n```\n\n### 8. Error Handling Tests\n\n```swift\nfunc testChemmacrosErrorHandling() throws {\n    var error: NSError? = nil\n    \n    // Missing closing brace\n    var list = MTMathListBuilder.build(fromString: \"\\\\ox{+2,Fe\", error: &error)\n    XCTAssertNotNil(error)\n    \n    // Invalid oxidation format\n    error = nil\n    list = MTMathListBuilder.build(fromString: \"\\\\ox{invalid}\", error: &error)\n    XCTAssertNotNil(error)\n    \n    // Empty phase\n    error = nil\n    list = MTMathListBuilder.build(fromString: \"\\\\phase{}\", error: &error)\n    // Should handle gracefully or error\n}\n```",
        "status": "pending",
        "dependencies": [
          2,
          5
        ],
        "priority": "low",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement eqnarray environment: Multi-line equations with alignment",
        "description": "Add comprehensive support for the eqnarray environment including round-trip LaTeX conversion, proper spacing/numbering conventions, and the eqnarray* variant for unnumbered equations.",
        "details": "## Implementation Overview\n\nThe `eqnarray` environment is **partially implemented** in `MTMathAtomFactory.swift` (lines 920-936). This task completes the implementation by adding round-trip conversion support, the starred variant, and comprehensive tests.\n\n## Current Implementation Status\n\n### Already Implemented (MTMathAtomFactory.swift:920-936)\n- 3-column structure with right-center-left (r-c-l) alignment\n- 18mu inter-column spacing\n- Standard inter-row spacing (1.0 additional)\n- Column count validation with error handling\n\n### Missing Components\n\n## 1. Round-Trip Conversion Support\n\nIn `MTMathListBuilder.swift`, the `mathListToString()` function handles `eqalign`, `aligned`, and `split` environments but NOT `eqnarray`. Add handling at line ~644:\n\n```swift\n// In mathListToString(), around line 644, after the eqalign/aligned/split handling:\nif table.environment == \"eqnarray\" {\n    // For eqnarray, we need to handle the 3-column structure\n    // The middle column contains the relation, remove any spacers if present\n    if j == 1 && cell.atoms.count >= 1 && cell.atoms[0].type == .ordinary && cell.atoms[0].nucleus.count == 0 {\n        cell.atoms.removeFirst()\n    }\n}\n```\n\nAlso update the begin/end wrapper logic to properly output `eqnarray` environment name.\n\n## 2. Add eqnarray* Variant (Unnumbered)\n\nAdd `eqnarray*` support in `MTMathAtomFactory.swift` alongside `eqnarray`:\n\n```swift\n} else if env == \"eqnarray\" || env == \"eqnarray*\" {\n    if table.numColumns != 3 {\n        let message = \"\\(env) environment can only have 3 columns\"\n        if error == nil {\n            error = NSError(domain: MTParseError, code: MTParseErrors.invalidNumColumns.rawValue, userInfo: [NSLocalizedDescriptionKey:message])\n        }\n        return nil\n    }\n    \n    // Preserve environment name for proper round-trip conversion\n    table.environment = env\n    table.interRowAdditionalSpacing = 1\n    table.interColumnSpacing = 18\n    \n    table.set(alignment: .right, forColumn: 0)\n    table.set(alignment: .center, forColumn: 1)\n    table.set(alignment: .left, forColumn: 2)\n    \n    return table\n}\n```\n\n## 3. Eqnarray-Specific Spacing\n\nThe eqnarray environment has specific spacing conventions that differ from the align family:\n- **Inter-column spacing**: 18mu around the middle column (relation symbol)\n- **Row spacing**: Standard display mode spacing with additional 1pt\n- **Alignment**: r-c-l pattern (right for LHS, center for relation, left for RHS)\n\nThe current implementation uses 18mu for `interColumnSpacing` which is correct.\n\n## 4. Usage Patterns\n\nEqnarray uses **two** `&` separators per row (creating 3 columns):\n\n```latex\n\\begin{eqnarray}\na + b &=& c \\\\\nx &=& y + z\n\\end{eqnarray}\n```\n\nThis differs from `align` which uses one `&` per row (creating 2 columns):\n\n```latex\n\\begin{align}\na + b &= c \\\\\nx &= y + z\n\\end{align}\n```\n\n## Files to Modify\n\n1. **Sources/SwiftMath/MathRender/MTMathAtomFactory.swift**\n   - Update `eqnarray` handling to preserve environment name\n   - Add `eqnarray*` variant support\n\n2. **Sources/SwiftMath/MathRender/MTMathListBuilder.swift**\n   - Add `eqnarray` and `eqnarray*` handling in `mathListToString()` around line 644\n   - Ensure proper round-trip conversion\n\n## Key Differences from align Environment\n\n| Feature | eqnarray | align |\n|---------|----------|-------|\n| Columns | 3 (r-c-l) | 2 (r-l) |\n| Separators | 2 `&` per row | 1 `&` per row |\n| Spacing | Wide (18mu) | Tight |\n| Starred | eqnarray* | align* |\n| Package | Base LaTeX | amsmath |",
        "testStrategy": "## Unit Tests (in MTMathListBuilderTests.swift)\n\n### 1. Basic Eqnarray Parsing Test\n\n```swift\nfunc testEqnarrayEnvironment() throws {\n    var error: NSError? = nil\n    let str = \"\\\\begin{eqnarray}a + b &=& c \\\\\\\\ x &=& y + z\\\\end{eqnarray}\"\n    let list = MTMathListBuilder.build(fromString: str, error: &error)\n    \n    XCTAssertNil(error)\n    XCTAssertNotNil(list)\n    XCTAssertEqual(list?.atoms.count, 1)\n    \n    let table = list?.atoms[0] as? MTMathTable\n    XCTAssertNotNil(table)\n    XCTAssertEqual(table?.environment, \"eqnarray\")\n    XCTAssertEqual(table?.numRows, 2)\n    XCTAssertEqual(table?.numColumns, 3)\n    \n    // Verify column alignments\n    XCTAssertEqual(table?.get(alignmentForColumn: 0), .right)\n    XCTAssertEqual(table?.get(alignmentForColumn: 1), .center)\n    XCTAssertEqual(table?.get(alignmentForColumn: 2), .left)\n}\n```\n\n### 2. Eqnarray Round-Trip Test\n\n```swift\nfunc testEqnarrayRoundTrip() throws {\n    var error: NSError? = nil\n    let original = \"\\\\begin{eqnarray}a&=&b \\\\\\\\ c&=&d\\\\end{eqnarray}\"\n    let list = MTMathListBuilder.build(fromString: original, error: &error)\n    \n    XCTAssertNil(error)\n    XCTAssertNotNil(list)\n    \n    let latex = MTMathListBuilder.mathListToString(list)\n    XCTAssertEqual(latex, \"\\\\begin{eqnarray}a&=&b\\\\\\\\ c&=&d\\\\end{eqnarray}\")\n}\n```\n\n### 3. Eqnarray* Variant Test\n\n```swift\nfunc testEqnarrayStarEnvironment() throws {\n    var error: NSError? = nil\n    let str = \"\\\\begin{eqnarray*}x &=& 1 \\\\\\\\ y &=& 2\\\\end{eqnarray*}\"\n    let list = MTMathListBuilder.build(fromString: str, error: &error)\n    \n    XCTAssertNil(error)\n    XCTAssertNotNil(list)\n    \n    let table = list?.atoms[0] as? MTMathTable\n    XCTAssertNotNil(table)\n    XCTAssertEqual(table?.environment, \"eqnarray*\")\n}\n```\n\n### 4. Invalid Column Count Test\n\n```swift\nfunc testEqnarrayInvalidColumns() throws {\n    var error: NSError? = nil\n    \n    // Only 2 columns (missing one &)\n    let str = \"\\\\begin{eqnarray}a &= c\\\\end{eqnarray}\"\n    let list = MTMathListBuilder.build(fromString: str, error: &error)\n    \n    XCTAssertNotNil(error)\n    XCTAssertEqual(error?.code, MTParseErrors.invalidNumColumns.rawValue)\n}\n```\n\n### 5. Complex Eqnarray Test\n\n```swift\nfunc testEqnarrayComplexExpressions() throws {\n    var error: NSError? = nil\n    let str = \"\"\"\n    \\\\begin{eqnarray}\n    \\\\int_0^\\\\infty e^{-x} dx &=& 1 \\\\\\\\\n    \\\\sum_{n=0}^\\\\infty \\\\frac{1}{n!} &=& e \\\\\\\\\n    \\\\lim_{x \\\\to 0} \\\\frac{\\\\sin x}{x} &=& 1\n    \\\\end{eqnarray}\n    \"\"\"\n    let list = MTMathListBuilder.build(fromString: str, error: &error)\n    \n    XCTAssertNil(error)\n    XCTAssertNotNil(list)\n    \n    let table = list?.atoms[0] as? MTMathTable\n    XCTAssertEqual(table?.numRows, 3)\n    XCTAssertEqual(table?.numColumns, 3)\n}\n```\n\n## Visual Render Tests (in MathImageTests.swift or new EqnarrayRenderTests.swift)\n\n### 1. Basic Eqnarray Rendering\n\n```swift\nfunc testEqnarrayRendering() throws {\n    let latex = \"\\\\begin{eqnarray}a + b &=& c \\\\\\\\ x - y &=& z\\\\end{eqnarray}\"\n    let label = MTMathUILabel()\n    label.latex = latex\n    label.fontSize = 20\n    \n    // Verify rendering doesn't crash\n    let size = label.sizeThatFits(CGSize(width: 300, height: 200))\n    XCTAssertGreaterThan(size.width, 0)\n    XCTAssertGreaterThan(size.height, 0)\n    \n    // Generate test image\n    // saveTestImage(label, name: \"eqnarray_basic\")\n}\n```\n\n### 2. Eqnarray vs Align Comparison\n\n```swift\nfunc testEqnarrayVsAlignSpacing() throws {\n    // Compare spacing between eqnarray (3-col) and align (2-col)\n    let eqnarrayLatex = \"\\\\begin{eqnarray}a &=& b\\\\end{eqnarray}\"\n    let alignLatex = \"\\\\begin{aligned}a &= b\\\\end{aligned}\"\n    \n    let eqnarrayLabel = MTMathUILabel()\n    eqnarrayLabel.latex = eqnarrayLatex\n    let eqnarraySize = eqnarrayLabel.sizeThatFits(CGSize(width: 300, height: 100))\n    \n    let alignLabel = MTMathUILabel()\n    alignLabel.latex = alignLatex\n    let alignSize = alignLabel.sizeThatFits(CGSize(width: 300, height: 100))\n    \n    // Eqnarray should be wider due to 18mu inter-column spacing\n    XCTAssertGreaterThan(eqnarraySize.width, alignSize.width)\n}\n```\n\n## Build Verification\n\n```bash\n# Run all tests\nswift test\n\n# Run specific eqnarray tests\nswift test --filter Eqnarray\n\n# Build to verify no compilation errors\nswift build\n```",
        "status": "pending",
        "dependencies": [],
        "priority": "low",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement tikz-feynhand package: Feynman diagram support",
        "description": "Add tikz-feynhand package support for rendering Feynman diagrams with fermion lines, boson lines, gluon lines, vertices, and propagator decorations, building on the TikZ core engine from Task 7.",
        "details": "## Implementation Overview\n\nThis task implements the tikz-feynhand package for Feynman diagram rendering, extending the TikZ core engine (Task 7). The package provides specialized commands for particle physics diagram notation.\n\n## 1. Architecture Design\n\n### New File Structure\nCreate the following files in `Sources/SwiftMath/MathRender/TikZ/`:\n\n```\nTikZ/\n├── MTFeynhandParser.swift       # Parses feynhand-specific commands\n├── MTFeynhandStyles.swift       # Line style definitions\n└── MTFeynhandDisplay.swift      # Custom display for propagator decorations\n```\n\n### Integration with TikZ Core\nThe feynhand implementation extends `MTTikZParser` and `MTTikZDisplay` from Task 7:\n- Register feynhand as a TikZ library via `\\usetikzlibrary{feynhand}`\n- Add feynhand-specific node shapes and line styles to the TikZ style registry\n- Extend path drawing to support decorations (sine waves, coils, dashes)\n\n## 2. Commands to Implement\n\n### Environment Commands\n| Command | Description |\n|---------|-------------|\n| `\\begin{feynhand}...\\end{feynhand}` | Feynman diagram environment (wrapper around tikzpicture) |\n\n### Vertex Commands\n| Command | Arguments | Description |\n|---------|-----------|-------------|\n| `\\vertex` | `(name) at (x,y) {...}` | Define a vertex at coordinates |\n| `\\vertex[particle]` | `(name) at (x,y) {label}` | External particle vertex with label |\n| `\\vertex[dot]` | `(name) at (x,y)` | Interaction vertex (filled dot) |\n| `\\vertex[ringdot]` | `(name) at (x,y)` | Interaction vertex (open circle) |\n| `\\vertex[crossdot]` | `(name) at (x,y)` | Interaction vertex (cross) |\n| `\\vertex[blob]` | `(name) at (x,y)` | Large blob vertex (effective interaction) |\n\n### Propagator Commands\n| Command | Arguments | Description |\n|---------|-----------|-------------|\n| `\\propagator` | `[type] (v1) to (v2)` | Generic propagator between vertices |\n| `\\propag` | `[type] (v1) to (v2)` | Shorthand for \\propagator |\n\n### Propagator Types (Line Styles)\n| Style | Rendering | Particle Type |\n|-------|-----------|---------------|\n| `fermion` | Solid line with arrow at midpoint | Fermions (e⁻, quarks) |\n| `anti fermion` | Solid line with reversed arrow | Antifermions |\n| `photon` | Sine wave pattern | Photons |\n| `boson` | Sine wave pattern | Generic vector bosons |\n| `gluon` | Coiled/loopy pattern | Gluons |\n| `scalar` | Dashed line | Scalar particles (Higgs) |\n| `ghost` | Dotted line | Faddeev-Popov ghosts |\n| `charged scalar` | Dashed line with arrow | Charged scalars |\n| `anti charged scalar` | Dashed line with reversed arrow | Charged scalar antiparticles |\n| `majorana` | Solid line with arrows on both ends | Majorana fermions |\n| `plain` | Simple solid line | No particle type |\n\n### Diagram Shorthands\n| Command | Equivalent |\n|---------|------------|\n| `\\graph` | Shorthand graph notation for complex diagrams |\n\n## 3. Implementation Details\n\n### MTFeynhandParser.swift\n\n```swift\n/// Parser for tikz-feynhand specific commands\nclass MTFeynhandParser {\n    \n    /// Supported vertex styles\n    enum VertexStyle: String {\n        case particle, dot, ringdot, crossdot, blob, empty\n    }\n    \n    /// Supported propagator styles\n    enum PropagatorStyle: String {\n        case fermion, antiFermion = \"anti fermion\"\n        case photon, boson, gluon\n        case scalar, ghost\n        case chargedScalar = \"charged scalar\"\n        case antiChargedScalar = \"anti charged scalar\"\n        case majorana, plain\n    }\n    \n    /// Parse \\vertex command\n    /// Format: \\vertex[style] (name) at (x,y) {label}\n    func parseVertex(_ scanner: String) -> MTFeynhandVertex? {\n        // Parse optional style in brackets\n        // Parse vertex name in parentheses\n        // Parse \"at\" keyword and coordinates\n        // Parse optional label in braces\n    }\n    \n    /// Parse \\propagator or \\propag command\n    /// Format: \\propagator[style] (v1) to[bend=angle] (v2)\n    func parsePropagator(_ scanner: String) -> MTFeynhandPropagator? {\n        // Parse optional style in brackets\n        // Parse source vertex name\n        // Parse \"to\" keyword with optional modifiers\n        // Parse destination vertex name\n    }\n}\n```\n\n### MTFeynhandStyles.swift\n\n```swift\n/// Rendering parameters for Feynman diagram elements\nstruct MTFeynhandStyles {\n    \n    /// Default line width for propagators\n    static let lineWidth: CGFloat = 0.5\n    \n    /// Amplitude and wavelength for photon/boson sine waves\n    static let sineAmplitude: CGFloat = 2.0\n    static let sineWavelength: CGFloat = 4.0\n    \n    /// Coil parameters for gluons\n    static let coilAmplitude: CGFloat = 2.5\n    static let coilSegmentLength: CGFloat = 3.0\n    \n    /// Dash pattern for scalar propagators\n    static let scalarDash: [CGFloat] = [3.0, 2.0]\n    \n    /// Dot pattern for ghost propagators\n    static let ghostDot: [CGFloat] = [1.0, 2.0]\n    \n    /// Arrow size for fermion direction indicators\n    static let arrowLength: CGFloat = 4.0\n    static let arrowAngle: CGFloat = 25.0 // degrees\n    \n    /// Vertex sizes\n    static let dotRadius: CGFloat = 2.0\n    static let ringDotRadius: CGFloat = 2.5\n    static let blobRadius: CGFloat = 8.0\n}\n```\n\n### MTFeynhandDisplay.swift\n\n```swift\n/// Display class for Feynman diagram propagators with decorations\nclass MTFeynhandPropagatorDisplay: MTDisplay {\n    \n    var startPoint: CGPoint\n    var endPoint: CGPoint\n    var style: MTFeynhandParser.PropagatorStyle\n    var bendAngle: CGFloat = 0  // For curved propagators\n    \n    override func draw(_ context: CGContext) {\n        super.draw(context)\n        \n        switch style {\n        case .fermion, .antiFermion, .majorana:\n            drawSolidLine(context)\n            drawArrow(context, reversed: style == .antiFermion)\n            if style == .majorana {\n                drawArrow(context, reversed: true, atStart: true)\n            }\n            \n        case .photon, .boson:\n            drawSineWave(context)\n            \n        case .gluon:\n            drawCoil(context)\n            \n        case .scalar:\n            drawDashedLine(context)\n            \n        case .ghost:\n            drawDottedLine(context)\n            \n        case .chargedScalar, .antiChargedScalar:\n            drawDashedLine(context)\n            drawArrow(context, reversed: style == .antiChargedScalar)\n            \n        case .plain:\n            drawSolidLine(context)\n        }\n    }\n    \n    /// Draw sine wave decoration for photons/bosons\n    private func drawSineWave(_ context: CGContext) {\n        let path = MTBezierPath()\n        let length = hypot(endPoint.x - startPoint.x, endPoint.y - startPoint.y)\n        let segments = Int(length / MTFeynhandStyles.sineWavelength)\n        \n        // Generate sine wave points along the line direction\n        // Transform coordinates to align with propagator direction\n        // Use quadratic bezier curves for smooth waves\n    }\n    \n    /// Draw coiled decoration for gluons\n    private func drawCoil(_ context: CGContext) {\n        // Generate loopy coil pattern\n        // Each coil segment is a small loop perpendicular to the line\n    }\n    \n    /// Draw midpoint arrow for fermions\n    private func drawArrow(_ context: CGContext, reversed: Bool, atStart: Bool = false) {\n        // Calculate arrow position (midpoint or specified location)\n        // Draw arrowhead pointing along propagator direction\n    }\n}\n\n/// Display class for Feynman diagram vertices\nclass MTFeynhandVertexDisplay: MTDisplay {\n    \n    var position: CGPoint\n    var style: MTFeynhandParser.VertexStyle\n    var label: MTMathList?\n    \n    override func draw(_ context: CGContext) {\n        super.draw(context)\n        \n        switch style {\n        case .dot:\n            drawFilledDot(context)\n        case .ringdot:\n            drawOpenCircle(context)\n        case .crossdot:\n            drawCross(context)\n        case .blob:\n            drawBlob(context)\n        case .particle, .empty:\n            // No decoration, just position for propagator endpoints\n            break\n        }\n        \n        // Draw label if present (using standard MTDisplay label rendering)\n        if let label = label {\n            drawLabel(context, label: label)\n        }\n    }\n}\n```\n\n## 4. Registration with TikZ Core\n\nIn `MTTikZParser.swift`, add feynhand library registration:\n\n```swift\nextension MTTikZParser {\n    \n    /// Register tikz-feynhand library commands\n    static func registerFeynhandLibrary() {\n        // Register feynhand environment\n        environmentHandlers[\"feynhand\"] = handleFeynhandEnvironment\n        \n        // Register vertex command\n        commandHandlers[\"vertex\"] = MTFeynhandParser.parseVertex\n        \n        // Register propagator commands\n        commandHandlers[\"propagator\"] = MTFeynhandParser.parsePropagator\n        commandHandlers[\"propag\"] = MTFeynhandParser.parsePropagator\n    }\n    \n    private static func handleFeynhandEnvironment(_ content: String) -> MTTikZDisplay? {\n        // Wrapper that creates tikzpicture with feynhand defaults\n        // Sets default styles: baseline, scale, etc.\n    }\n}\n```\n\n## 5. Coordinate System\n\nFeynhand uses the same coordinate system as TikZ:\n- Origin at center of diagram\n- Positive x to the right, positive y upward\n- Coordinates in pts (or scaled units)\n- Support for relative positioning via `++` and `+` notation\n\n## 6. Bending and Loops\n\nSupport for curved propagators:\n- `\\propagator[fermion, bend left=30] (a) to (b)` - Curved arc\n- `\\propagator[gluon, half left] (a) to (b)` - Semicircle\n- `\\propagator[photon, loop] (a) to (a)` - Self-loop (tadpole)\n\n## 7. Dependencies\n\n- Task 7 (TikZ core engine): Provides `MTTikZParser`, `MTTikZPath`, `MTTikZNode`, `MTTikZDisplay`\n- Task 5 (Package registry): For registering feynhand as a TikZ library",
        "testStrategy": "## Unit Tests (in MTFeynhandTests.swift)\n\n### 1. Environment Parsing Tests\n\n```swift\nfunc testFeynhandEnvironmentParsing() throws {\n    var error: NSError? = nil\n    let str = \"\\\\begin{feynhand}\\\\vertex (a) at (0,0); \\\\vertex (b) at (2,0);\\\\end{feynhand}\"\n    let list = MTMathListBuilder.build(fromString: str, error: &error)\n    XCTAssertNil(error)\n    XCTAssertNotNil(list)\n    XCTAssertEqual(list?.atoms.count, 1)\n    // Verify TikZ display was created with feynhand defaults\n}\n```\n\n### 2. Vertex Parsing Tests\n\n```swift\nfunc testVertexParsing() throws {\n    var error: NSError? = nil\n    \n    // Test basic vertex\n    let v1 = \"\\\\begin{feynhand}\\\\vertex (a) at (0,0);\\\\end{feynhand}\"\n    var list = MTMathListBuilder.build(fromString: v1, error: &error)\n    XCTAssertNil(error)\n    \n    // Test vertex with style\n    let v2 = \"\\\\begin{feynhand}\\\\vertex[dot] (b) at (1,1);\\\\end{feynhand}\"\n    list = MTMathListBuilder.build(fromString: v2, error: &error)\n    XCTAssertNil(error)\n    \n    // Test vertex with label\n    let v3 = \"\\\\begin{feynhand}\\\\vertex[particle] (e) at (0,0) {$e^-$};\\\\end{feynhand}\"\n    list = MTMathListBuilder.build(fromString: v3, error: &error)\n    XCTAssertNil(error)\n}\n\nfunc testVertexStyles() throws {\n    let styles = [\"dot\", \"ringdot\", \"crossdot\", \"blob\", \"particle\"]\n    \n    for style in styles {\n        var error: NSError? = nil\n        let str = \"\\\\begin{feynhand}\\\\vertex[\\(style)] (v) at (0,0);\\\\end{feynhand}\"\n        let list = MTMathListBuilder.build(fromString: str, error: &error)\n        XCTAssertNil(error, \"Failed to parse vertex style: \\(style)\")\n    }\n}\n```\n\n### 3. Propagator Parsing Tests\n\n```swift\nfunc testPropagatorParsing() throws {\n    var error: NSError? = nil\n    \n    // Test basic propagator\n    let p1 = \"\"\"\n    \\\\begin{feynhand}\n    \\\\vertex (a) at (0,0);\n    \\\\vertex (b) at (2,0);\n    \\\\propagator[fermion] (a) to (b);\n    \\\\end{feynhand}\n    \"\"\"\n    var list = MTMathListBuilder.build(fromString: p1, error: &error)\n    XCTAssertNil(error)\n    \n    // Test shorthand\n    let p2 = \"\"\"\n    \\\\begin{feynhand}\n    \\\\vertex (a) at (0,0);\n    \\\\vertex (b) at (2,0);\n    \\\\propag[photon] (a) to (b);\n    \\\\end{feynhand}\n    \"\"\"\n    list = MTMathListBuilder.build(fromString: p2, error: &error)\n    XCTAssertNil(error)\n}\n\nfunc testPropagatorStyles() throws {\n    let styles = [\n        \"fermion\", \"anti fermion\", \"photon\", \"boson\", \"gluon\",\n        \"scalar\", \"ghost\", \"charged scalar\", \"anti charged scalar\",\n        \"majorana\", \"plain\"\n    ]\n    \n    for style in styles {\n        var error: NSError? = nil\n        let str = \"\"\"\n        \\\\begin{feynhand}\n        \\\\vertex (a) at (0,0);\n        \\\\vertex (b) at (2,0);\n        \\\\propagator[\\(style)] (a) to (b);\n        \\\\end{feynhand}\n        \"\"\"\n        let list = MTMathListBuilder.build(fromString: str, error: &error)\n        XCTAssertNil(error, \"Failed to parse propagator style: \\(style)\")\n    }\n}\n```\n\n### 4. Curved Propagator Tests\n\n```swift\nfunc testBendingPropagators() throws {\n    var error: NSError? = nil\n    \n    // Test bend left\n    let b1 = \"\"\"\n    \\\\begin{feynhand}\n    \\\\vertex (a) at (0,0);\n    \\\\vertex (b) at (2,0);\n    \\\\propagator[fermion, bend left=30] (a) to (b);\n    \\\\end{feynhand}\n    \"\"\"\n    var list = MTMathListBuilder.build(fromString: b1, error: &error)\n    XCTAssertNil(error)\n    \n    // Test half left (semicircle)\n    let b2 = \"\"\"\n    \\\\begin{feynhand}\n    \\\\vertex (a) at (0,0);\n    \\\\vertex (b) at (2,0);\n    \\\\propagator[gluon, half left] (a) to (b);\n    \\\\end{feynhand}\n    \"\"\"\n    list = MTMathListBuilder.build(fromString: b2, error: &error)\n    XCTAssertNil(error)\n}\n```\n\n### 5. Complete Diagram Tests\n\n```swift\nfunc testQEDVertexDiagram() throws {\n    var error: NSError? = nil\n    \n    // Simple QED vertex: electron-photon-electron\n    let qed = \"\"\"\n    \\\\begin{feynhand}\n    \\\\vertex[particle] (i) at (0,0) {$e^-$};\n    \\\\vertex[dot] (v) at (2,0);\n    \\\\vertex[particle] (f) at (4,0) {$e^-$};\n    \\\\vertex (g) at (2,2);\n    \\\\propagator[fermion] (i) to (v);\n    \\\\propagator[fermion] (v) to (f);\n    \\\\propagator[photon] (v) to (g);\n    \\\\end{feynhand}\n    \"\"\"\n    let list = MTMathListBuilder.build(fromString: qed, error: &error)\n    XCTAssertNil(error)\n    XCTAssertNotNil(list)\n}\n\nfunc testGluonSelfEnergy() throws {\n    var error: NSError? = nil\n    \n    // Gluon self-energy with quark loop\n    let diagram = \"\"\"\n    \\\\begin{feynhand}\n    \\\\vertex (i) at (0,0);\n    \\\\vertex[dot] (v1) at (1,0);\n    \\\\vertex[dot] (v2) at (3,0);\n    \\\\vertex (f) at (4,0);\n    \\\\propagator[gluon] (i) to (v1);\n    \\\\propagator[fermion, half left] (v1) to (v2);\n    \\\\propagator[fermion, half left] (v2) to (v1);\n    \\\\propagator[gluon] (v2) to (f);\n    \\\\end{feynhand}\n    \"\"\"\n    let list = MTMathListBuilder.build(fromString: diagram, error: &error)\n    XCTAssertNil(error)\n}\n```\n\n### 6. Visual Render Tests (in MTFeynhandRenderTests.swift)\n\n```swift\nfunc testFermionLineRendering() throws {\n    // Create diagram, render to image, verify:\n    // - Solid line drawn between vertices\n    // - Arrow present at midpoint\n    // - Arrow points in correct direction\n}\n\nfunc testPhotonWaveRendering() throws {\n    // Create diagram, render to image, verify:\n    // - Sine wave pattern drawn\n    // - Correct amplitude and wavelength\n    // - Smooth curves (no jagged edges)\n}\n\nfunc testGluonCoilRendering() throws {\n    // Create diagram, render to image, verify:\n    // - Coiled/loopy pattern drawn\n    // - Coils perpendicular to propagator direction\n}\n\nfunc testVertexRendering() throws {\n    // Test each vertex style renders correctly:\n    // - dot: filled circle\n    // - ringdot: open circle\n    // - crossdot: X mark\n    // - blob: large filled circle or ellipse\n}\n```\n\n### 7. Error Handling Tests\n\n```swift\nfunc testInvalidVertexReference() throws {\n    var error: NSError? = nil\n    \n    // Reference undefined vertex\n    let str = \"\"\"\n    \\\\begin{feynhand}\n    \\\\vertex (a) at (0,0);\n    \\\\propagator[fermion] (a) to (undefined);\n    \\\\end{feynhand}\n    \"\"\"\n    let list = MTMathListBuilder.build(fromString: str, error: &error)\n    XCTAssertNotNil(error)\n    XCTAssertEqual((error as NSError?)?.code, MTParseErrors.invalidCommand.rawValue)\n}\n\nfunc testInvalidPropagatorStyle() throws {\n    var error: NSError? = nil\n    \n    let str = \"\"\"\n    \\\\begin{feynhand}\n    \\\\vertex (a) at (0,0);\n    \\\\vertex (b) at (2,0);\n    \\\\propagator[invalidstyle] (a) to (b);\n    \\\\end{feynhand}\n    \"\"\"\n    let list = MTMathListBuilder.build(fromString: str, error: &error)\n    XCTAssertNotNil(error)\n}\n```\n\n### 8. Round-Trip Conversion Tests\n\n```swift\nfunc testFeynhandRoundTrip() throws {\n    let original = \"\"\"\n    \\\\begin{feynhand}\n    \\\\vertex[particle] (a) at (0,0) {$e^-$};\n    \\\\vertex[dot] (v) at (2,0);\n    \\\\vertex[particle] (b) at (4,0) {$e^-$};\n    \\\\propagator[fermion] (a) to (v);\n    \\\\propagator[fermion] (v) to (b);\n    \\\\end{feynhand}\n    \"\"\"\n    \n    var error: NSError? = nil\n    let list = MTMathListBuilder.build(fromString: original, error: &error)\n    XCTAssertNil(error)\n    \n    let output = MTMathListBuilder.toLatexString(list)\n    let reparsed = MTMathListBuilder.build(fromString: output, error: &error)\n    XCTAssertNil(error)\n    \n    // Verify structural equivalence\n}",
        "status": "pending",
        "dependencies": [
          7,
          5
        ],
        "priority": "low",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2026-01-10T18:13:12.393Z",
      "updated": "2026-01-10T23:17:40.939Z",
      "description": "=Future enhancements and package implementations"
    }
  }
}